/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TableRollerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/services/TableParser.ts
var TableParser = class {
  /**
   * Extract YAML frontmatter from markdown content
   */
  static extractFrontmatter(content) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      return { frontmatter: {}, content };
    }
    const frontmatterText = match[1];
    const bodyContent = match[2];
    const frontmatter = {};
    for (const line of frontmatterText.split("\n")) {
      const keyValue = line.match(/^(\w+(?:-\w+)*)\s*:\s*(.+)$/);
      if (keyValue) {
        const key = keyValue[1].trim();
        let value = keyValue[2].trim();
        if (value === "true")
          value = true;
        else if (value === "false")
          value = false;
        else if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
          value = value.slice(1, -1);
        }
        frontmatter[key] = value;
      }
    }
    return { frontmatter, content: bodyContent };
  }
  /**
   * Parse all tables from markdown content
   */
  static parseTables(content, namespace) {
    const { frontmatter, content: bodyContent } = this.extractFrontmatter(content);
    const isTableFile = frontmatter["table-roller"] === true;
    const tables = {};
    const lines = bodyContent.split("\n");
    let currentTableName = null;
    let currentTableReroll = void 0;
    let currentTablePrivate = false;
    let currentTable = [];
    let inTable = false;
    let tableCount = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      const headingMatch = line.match(/^#{1,6}\s+(.+)$/);
      if (headingMatch) {
        if (inTable && currentTable.length > 0) {
          const parsed = this.parseTable(currentTable);
          if (parsed && currentTableName) {
            tables[currentTableName] = this.processTable(parsed, currentTableReroll, currentTablePrivate);
          }
          inTable = false;
          currentTable = [];
          currentTableReroll = void 0;
          currentTablePrivate = false;
        }
        currentTableName = headingMatch[1].trim();
        console.log(`Found heading: "${currentTableName}"`);
        continue;
      }
      const rerollMatch = line.match(/^reroll:\s*(.+)$/i);
      if (rerollMatch && currentTableName && !inTable) {
        currentTableReroll = rerollMatch[1].trim();
        continue;
      }
      const privateMatch = line.match(/^private:\s*(true|yes|1)$/i);
      if (privateMatch && currentTableName && !inTable) {
        currentTablePrivate = true;
        continue;
      }
      if (line.includes("|")) {
        if (!inTable) {
          inTable = true;
          currentTable = [];
          if (!currentTableName) {
            tableCount++;
            currentTableName = `${namespace}${tableCount}`;
          }
        }
        currentTable.push(line);
      } else if (inTable && currentTable.length > 0) {
        const parsed = this.parseTable(currentTable);
        if (parsed && currentTableName) {
          tables[currentTableName] = this.processTable(parsed, currentTableReroll, currentTablePrivate);
        }
        inTable = false;
        currentTable = [];
        currentTableName = null;
        currentTableReroll = void 0;
        currentTablePrivate = false;
        currentTablePrivate = false;
      }
    }
    if (inTable && currentTable.length > 0 && currentTableName) {
      const parsed = this.parseTable(currentTable);
      if (parsed) {
        tables[currentTableName] = this.processTable(parsed, currentTableReroll, currentTablePrivate);
      }
    }
    return { tables, frontmatter, isTableFile, namespace };
  }
  /**
   * Parse a single markdown table into structured data
   */
  static parseTable(lines) {
    if (lines.length < 3)
      return null;
    const headerLine = lines[0];
    const headers = headerLine.split("|").map((h) => h.trim()).filter((h) => h.length > 0);
    if (headers.length === 0)
      return null;
    const rows = [];
    for (let i = 2; i < lines.length; i++) {
      const cells = lines[i].split("|").map((c) => c.trim()).filter((_, idx) => idx > 0 && idx <= headers.length);
      if (cells.length > 0) {
        const row = {};
        headers.forEach((header, idx) => {
          row[header] = cells[idx] || "";
        });
        rows.push(row);
      }
    }
    return { headers, rows };
  }
  /**
   * Process parsed table into dice or simple format
   */
  static processTable(parsed, tableReroll, tablePrivate) {
    const diceHeader = parsed.headers.find((h) => /^\d*d\d+$/i.test(h.trim()));
    if (diceHeader) {
      return this.processDiceTable(parsed, diceHeader, tableReroll, tablePrivate);
    } else {
      const table = {
        headers: parsed.headers,
        rows: parsed.rows
      };
      if (tableReroll) {
        table.reroll = tableReroll;
      }
      if (tablePrivate) {
        table.private = tablePrivate;
      }
      return table;
    }
  }
  /**
   * Process a dice-based table
   */
  static processDiceTable(parsed, diceHeader, tableReroll, tablePrivate) {
    const entries = [];
    const rerollHeader = parsed.headers.find((h) => /^reroll$/i.test(h.trim()));
    for (const row of parsed.rows) {
      const range = row[diceHeader];
      const { min, max } = this.parseRange(range);
      let result = "";
      let details = "";
      let reroll;
      const columns = {};
      for (const [key, value] of Object.entries(row)) {
        if (key === diceHeader)
          continue;
        const isRerollColumn = rerollHeader && key.toLowerCase().trim() === rerollHeader.toLowerCase().trim();
        if (isRerollColumn) {
          const trimmed = value.trim();
          if (trimmed && trimmed !== "\u2014" && trimmed !== "-") {
            reroll = trimmed;
          }
          continue;
        }
        if (!value || !value.trim())
          continue;
        columns[key] = value;
        if (!result) {
          result = value;
        } else if (!details) {
          details = value;
        } else {
          details += " | " + value;
        }
      }
      const entry = { min, max, result, columns };
      if (details)
        entry.details = details;
      if (reroll)
        entry.reroll = reroll;
      entries.push(entry);
    }
    const table = {
      dice: diceHeader.toLowerCase(),
      entries
    };
    if (tableReroll) {
      table.reroll = tableReroll;
    }
    if (tablePrivate) {
      table.private = tablePrivate;
    }
    return table;
  }
  /**
   * Parse a range string into min/max values
   */
  static parseRange(rangeStr) {
    if (!rangeStr)
      return { min: 0, max: 0 };
    const trimmed = rangeStr.trim();
    if (/^\d+$/.test(trimmed)) {
      const num = parseInt(trimmed);
      return { min: num, max: num };
    }
    const rangeMatch = trimmed.match(/^(\d+)[\-\u2013\u2014](\d+)$/);
    if (rangeMatch) {
      return {
        min: parseInt(rangeMatch[1]),
        max: parseInt(rangeMatch[2])
      };
    }
    const openMatch = trimmed.match(/^(\d+)\+$/);
    if (openMatch) {
      return {
        min: parseInt(openMatch[1]),
        max: 999
      };
    }
    return { min: 0, max: 0 };
  }
};

// src/services/DiceRoller.ts
var DiceRoller = class {
  /**
   * Roll dice using standard notation (e.g., "2d6+3", "d20", "1d100-5")
   */
  static roll(notation) {
    const match = notation.match(/(\d*)d(\d+)([+-]\d+)?/i);
    if (!match) {
      throw new Error(`Invalid dice notation: ${notation}`);
    }
    const count = match[1] ? parseInt(match[1]) : 1;
    const sides = parseInt(match[2]);
    const modifier = match[3] ? parseInt(match[3]) : 0;
    let total = 0;
    for (let i = 0; i < count; i++) {
      total += Math.floor(Math.random() * sides) + 1;
    }
    return total + modifier;
  }
  /**
   * Check if a number falls within a range string (e.g., "1-3", "4", "5+")
   */
  static isInRange(value, rangeStr) {
    const trimmed = rangeStr.trim();
    if (/^\d+$/.test(trimmed)) {
      return value === parseInt(trimmed);
    }
    const rangeMatch = trimmed.match(/^(\d+)-(\d+)$/);
    if (rangeMatch) {
      const min = parseInt(rangeMatch[1]);
      const max = parseInt(rangeMatch[2]);
      return value >= min && value <= max;
    }
    const openMatch = trimmed.match(/^(\d+)\+$/);
    if (openMatch) {
      const min = parseInt(openMatch[1]);
      return value >= min;
    }
    return false;
  }
};

// src/services/TableRollerCore.ts
var TableRollerCore = class {
  constructor(app) {
    this.tables = /* @__PURE__ */ new Map();
    this.app = app;
  }
  /**
   * Load all tables from vault files with frontmatter
   */
  async loadTables() {
    this.tables.clear();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      await this.loadTableFromFile(file);
    }
    console.log(`Loaded ${this.tables.size} tables from ${files.length} files`);
  }
  /**
   * Load tables from a single file
   */
  async loadTableFromFile(file) {
    const content = await this.app.vault.read(file);
    const namespace = file.basename;
    const parsed = TableParser.parseTables(content, namespace);
    if (!parsed.isTableFile) {
      return;
    }
    for (const [name, table] of Object.entries(parsed.tables)) {
      const fullName = `${namespace}.${name}`;
      this.tables.set(fullName, { table, namespace, file });
    }
  }
  /**
   * Get source file path for a table
   */
  getTableFile(tableName, contextNamespace) {
    const tableData = this.findTable(tableName, contextNamespace);
    return tableData == null ? void 0 : tableData.file;
  }
  /**
   * Get list of all available table names
   */
  getTableNames() {
    const names = /* @__PURE__ */ new Set();
    for (const [key, data] of this.tables.entries()) {
      if (!data.table.private) {
        const parts = key.split(".");
        if (parts.length === 2) {
          names.add(parts[1]);
        }
      }
    }
    return Array.from(names).sort();
  }
  /**
   * Roll on a table by name
   */
  roll(tableName, contextNamespace, modifier = 0) {
    const tableData = this.findTable(tableName, contextNamespace);
    if (!tableData) {
      throw new Error(`Table not found: ${tableName}`);
    }
    return this.rollOnTable(tableName, tableData.table, tableData.namespace, tableData.file.path, modifier);
  }
  /**
   * Roll on a specific table
   */
  rollOnTable(tableName, table, namespace, sourceFile, modifier = 0, callChain = []) {
    let result;
    if (this.isDiceTable(table)) {
      result = this.rollDiceTable(tableName, table, namespace, sourceFile, modifier, callChain);
    } else {
      result = this.rollSimpleTable(tableName, table, namespace, sourceFile);
    }
    if (table.reroll) {
      const tableRerolls = this.resolveRerolls(table.reroll, namespace, 0, callChain);
      if (result.nestedRolls) {
        result.nestedRolls.push(...tableRerolls);
      } else {
        result.nestedRolls = tableRerolls;
      }
    }
    return result;
  }
  /**
   * Roll on a dice-based table
   */
  rollDiceTable(tableName, table, namespace, sourceFile, modifier = 0, callChain = []) {
    const tableIdentifier = `${namespace}.${tableName}`;
    const isSelfReference = callChain.includes(tableIdentifier);
    let availableEntries = table.entries;
    if (isSelfReference) {
      availableEntries = table.entries.filter((entry2) => {
        if (!entry2.reroll)
          return true;
        const rerollTables = entry2.reroll.split(",").map((t) => t.trim());
        for (const rerollRef of rerollTables) {
          const multiRollMatch = rerollRef.match(/^(\d*d\d+)\s+(.+)$/i);
          const rerollTableName = multiRollMatch ? multiRollMatch[2].trim() : rerollRef;
          if (rerollTableName === tableName || rerollTableName === tableIdentifier) {
            return false;
          }
        }
        return true;
      });
      if (availableEntries.length === 0) {
        throw new Error(`All entries in ${tableName} would cause infinite self-reroll`);
      }
    }
    let entry = null;
    let rollValue = 0;
    if (isSelfReference) {
      const randomEntry = availableEntries[Math.floor(Math.random() * availableEntries.length)];
      entry = randomEntry;
      rollValue = randomEntry.min + Math.floor(Math.random() * (randomEntry.max - randomEntry.min + 1));
    } else {
      const baseRoll = DiceRoller.roll(table.dice);
      rollValue = baseRoll + modifier;
      const minBound = Math.min(...table.entries.map((e) => e.min));
      const maxBound = Math.max(...table.entries.map((e) => e.max));
      rollValue = Math.max(minBound, Math.min(maxBound, rollValue));
      entry = availableEntries.find((e) => rollValue >= e.min && rollValue <= e.max);
      if (!entry) {
        throw new Error(`No entry found for roll ${rollValue} on table ${tableName}`);
      }
    }
    const result = {
      tableName,
      namespace,
      roll: rollValue,
      result: entry.result,
      details: entry.details,
      columns: entry.columns,
      sourceFile
    };
    if (entry.reroll) {
      result.nestedRolls = this.resolveRerolls(entry.reroll, namespace, 0, callChain);
    }
    return result;
  }
  /**
   * Roll on a simple table (random row selection)
   */
  rollSimpleTable(tableName, table, namespace, sourceFile) {
    const randomIndex = Math.floor(Math.random() * table.rows.length);
    const row = table.rows[randomIndex];
    const resultParts = [];
    for (const [key, value] of Object.entries(row)) {
      if (value && typeof value === "string" && value.trim()) {
        resultParts.push(`**${key}:** ${value}`);
      }
    }
    return {
      tableName,
      namespace,
      result: resultParts.join("\n"),
      sourceFile
    };
  }
  /**
   * Resolve reroll references (comma-delimited table names)
   * Supports multi-roll syntax: d6 TableName, 1d6 TableName, 2d8 TableName, etc.
   * Deduplicates results for self-referencing tables to ensure unique results.
   */
  resolveRerolls(rerollString, contextNamespace, modifier = 0, callChain = []) {
    const tableNames = rerollString.split(",").map((t) => t.trim()).filter((t) => t);
    const results = [];
    for (const name of tableNames) {
      const multiRollMatch = name.match(/^(\d*d\d+)\s+(.+)$/i);
      let rollCount = 1;
      let actualTableName = name;
      if (multiRollMatch) {
        try {
          rollCount = DiceRoller.roll(multiRollMatch[1]);
          actualTableName = multiRollMatch[2].trim();
        } catch (error) {
          console.warn(`Invalid dice notation in reroll: ${multiRollMatch[1]}`, error);
          continue;
        }
      }
      const tableData = this.findTable(actualTableName, contextNamespace);
      if (tableData) {
        const tableIdentifier = `${tableData.namespace}.${actualTableName}`;
        if (callChain.includes(tableIdentifier)) {
          try {
            const uniqueResults = this.rollUniqueResults(
              actualTableName,
              tableData.table,
              tableData.namespace,
              tableData.file.path,
              rollCount,
              modifier,
              [...callChain, tableIdentifier]
            );
            results.push(...uniqueResults);
          } catch (error) {
            console.warn(`Failed to roll on ${actualTableName}:`, error);
          }
        } else {
          try {
            for (let i = 0; i < rollCount; i++) {
              results.push(this.rollOnTable(actualTableName, tableData.table, tableData.namespace, tableData.file.path, modifier, [...callChain, tableIdentifier]));
            }
          } catch (error) {
            console.warn(`Failed to roll on ${actualTableName}:`, error);
          }
        }
      } else {
        console.warn(`Table not found for reroll: ${actualTableName}`);
      }
    }
    return results;
  }
  /**
   * Roll on a table multiple times and return unique results when possible
   * Used for self-referencing tables. Returns unique results first, then duplicates if needed.
   */
  rollUniqueResults(tableName, table, namespace, sourceFile, desiredCount, modifier, callChain) {
    const allResults = [];
    const uniqueResults = [];
    const seenResults = /* @__PURE__ */ new Set();
    const maxUniqueAttempts = desiredCount * 10;
    let attempts = 0;
    while (uniqueResults.length < desiredCount && attempts < maxUniqueAttempts) {
      attempts++;
      const result = this.rollOnTable(tableName, table, namespace, sourceFile, modifier, callChain);
      const resultKey = result.result;
      if (!seenResults.has(resultKey)) {
        seenResults.add(resultKey);
        uniqueResults.push(result);
      }
    }
    allResults.push(...uniqueResults);
    if (allResults.length < desiredCount) {
      const remaining = desiredCount - allResults.length;
      for (let i = 0; i < remaining; i++) {
        const result = this.rollOnTable(tableName, table, namespace, sourceFile, modifier, callChain);
        allResults.push(result);
      }
    }
    return allResults;
  }
  /**
   * Find a table by name with namespace resolution
   * Supports:
   * - Short name (within same namespace)
   * - Full name (Namespace.TableName)
   * - Case-insensitive matching
   * Throws error if ambiguous matches found across files
   */
  findTable(searchName, contextNamespace) {
    if (searchName.includes(".")) {
      const tableData = this.tables.get(searchName);
      if (tableData)
        return tableData;
      const lower2 = searchName.toLowerCase();
      for (const [key, data] of this.tables.entries()) {
        if (key.toLowerCase() === lower2) {
          return data;
        }
      }
      return null;
    }
    if (contextNamespace) {
      const namespacedName = `${contextNamespace}.${searchName}`;
      const localTable = this.tables.get(namespacedName);
      if (localTable) {
        return localTable;
      }
    }
    const matches = [];
    const lower = searchName.toLowerCase();
    for (const [key, data] of this.tables.entries()) {
      const parts = key.split(".");
      if (parts.length !== 2)
        continue;
      const tableName = parts[1];
      if (tableName.toLowerCase() === lower) {
        matches.push({ key, data });
      }
    }
    if (matches.length === 0) {
      return null;
    }
    if (matches.length === 1) {
      return matches[0].data;
    }
    const fileList = matches.map((m) => m.data.namespace).join(", ");
    throw new Error(
      `Ambiguous table reference: "${searchName}" exists in multiple files (${fileList}). Use the format "FileName.${searchName}" to specify which table to use.`
    );
  }
  /**
   * Check if a table is dice-based
   */
  isDiceTable(table) {
    return "dice" in table && "entries" in table;
  }
};

// src/ui/modals.ts
var import_obsidian = require("obsidian");
var TableSelectorModal = class extends import_obsidian.Modal {
  constructor(app, tables, onSelect, roller) {
    super(app);
    this.showRollNumbers = false;
    this.tables = tables;
    this.onSelect = onSelect;
    this.roller = roller;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select a table to roll on" });
    const checkboxContainer = contentEl.createEl("div", { cls: "modal-checkbox-container" });
    const checkboxLabel = checkboxContainer.createEl("label", { cls: "modal-checkbox-label" });
    const checkbox = checkboxLabel.createEl("input", { type: "checkbox", cls: "modal-checkbox" });
    const labelText = checkboxLabel.createEl("span", {
      text: "Roll with modifiers",
      cls: "modal-checkbox-text"
    });
    let useModifiers = false;
    checkbox.addEventListener("change", () => {
      useModifiers = checkbox.checked;
    });
    const rollNumsContainer = contentEl.createEl("div", { cls: "modal-checkbox-container" });
    const rollNumsLabel = rollNumsContainer.createEl("label", { cls: "modal-checkbox-label" });
    const rollNumsCheckbox = rollNumsLabel.createEl("input", { type: "checkbox", cls: "modal-checkbox" });
    const rollNumsLabelText = rollNumsLabel.createEl("span", {
      text: "Show roll numbers",
      cls: "modal-checkbox-text"
    });
    rollNumsCheckbox.addEventListener("change", () => {
      this.showRollNumbers = rollNumsCheckbox.checked;
    });
    const listEl = contentEl.createEl("div", { cls: "modal-table-list" });
    for (const tableName of this.tables) {
      const buttonEl = listEl.createEl("button", {
        text: tableName,
        cls: "modal-table-button"
      });
      buttonEl.addEventListener("click", () => {
        if (useModifiers) {
          new ModifierPreviewModal(this.app, tableName, this.onSelect).open();
        } else {
          this.onSelect(tableName);
        }
        this.close();
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var RollResultModal = class extends import_obsidian.Modal {
  constructor(app, result, onReroll, showRollNumbers = false) {
    super(app);
    this.result = result;
    this.onReroll = onReroll;
    this.showRollNumbers = showRollNumbers;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.displayResult(contentEl, this.result, 2, this.showRollNumbers);
    const buttonDiv = contentEl.createEl("div", { cls: "modal-button-container" });
    const leftDiv = buttonDiv.createEl("div", { cls: "modal-button-group" });
    if (this.onReroll) {
      const rerollButton = leftDiv.createEl("button", { text: "Reroll" });
      rerollButton.addEventListener("click", () => {
        var _a;
        this.close();
        (_a = this.onReroll) == null ? void 0 : _a.call(this);
      });
    }
    const rightDiv = buttonDiv.createEl("div", { cls: "modal-button-group" });
    const copyButton = rightDiv.createEl("button", { text: "Copy to Clipboard" });
    copyButton.addEventListener("click", async () => {
      const markdown = this.formatResultAsMarkdown(this.result);
      await navigator.clipboard.writeText(markdown);
      copyButton.textContent = "Copied!";
      setTimeout(() => {
        copyButton.textContent = "Copy to Clipboard";
      }, 2e3);
    });
    const saveButton = rightDiv.createEl("button", { text: "Save to Obsidian" });
    saveButton.addEventListener("click", () => {
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -5);
      const defaultFilename = `${this.result.tableName}-${timestamp}`;
      const markdown = this.formatResultAsMarkdown(this.result);
      new SaveFileModal(this.app, defaultFilename, markdown).open();
    });
    const closeButton = rightDiv.createEl("button", { text: "Close" });
    closeButton.addEventListener("click", () => this.close());
  }
  /**
   * Format result as markdown string
   */
  formatResultAsMarkdown(result, level = 2) {
    const lines = [];
    const heading = "#".repeat(level);
    lines.push(`${heading} ${result.tableName}`);
    if (result.namespace) {
      lines.push(`*[[${result.namespace}]]*`);
    }
    lines.push("");
    if (result.columns && Object.keys(result.columns).length > 0) {
      for (const [header, value] of Object.entries(result.columns)) {
        if (value && value.trim()) {
          lines.push(`**${header}:** ${value}`);
        }
      }
    } else {
      lines.push(`**Result:** ${result.result}`);
      if (result.details) {
        lines.push(`**Details:** ${result.details}`);
      }
    }
    if (this.showRollNumbers && result.roll !== void 0) {
      lines.push(`**Roll:** ${result.roll}`);
    }
    if (result.nestedRolls && result.nestedRolls.length > 0) {
      lines.push("");
      lines.push("**Referenced Tables:**");
      lines.push("");
      for (const nested of result.nestedRolls) {
        lines.push(this.formatResultAsMarkdown(nested, Math.min(level + 1, 6)));
      }
    }
    return lines.join("\n");
  }
  displayResult(container, result, headingLevel, showRollNumbers = false) {
    const heading = container.createEl(`h${headingLevel}`, { text: result.tableName });
    if (result.namespace) {
      const namespaceBadge = heading.createEl("span", {
        cls: "modal-namespace-badge"
      });
      if (result.sourceFile) {
        const link = namespaceBadge.createEl("a", {
          text: ` [${result.namespace}]`,
          href: "#",
          cls: "modal-namespace-link"
        });
        link.addEventListener("click", async (e) => {
          e.preventDefault();
          const file = this.app.vault.getAbstractFileByPath(result.sourceFile);
          if (file && file instanceof import_obsidian.TFile) {
            await this.app.workspace.getLeaf().openFile(file);
            this.close();
          }
        });
      } else {
        namespaceBadge.textContent = ` [${result.namespace}]`;
      }
    }
    if (result.columns && Object.keys(result.columns).length > 0) {
      for (const [header, value] of Object.entries(result.columns)) {
        if (value && value.trim()) {
          const colEl = container.createEl("div", { cls: "modal-result-column" });
          colEl.innerHTML = `<strong>${header}:</strong> ${value}`;
        }
      }
    } else {
      const resultEl = container.createEl("div", { cls: "modal-result-text" });
      resultEl.innerHTML = `<strong>Result:</strong> ${result.result}`;
      if (result.details) {
        const detailsEl = container.createEl("div", { cls: "modal-result-details" });
        detailsEl.innerHTML = `<strong>Details:</strong> ${result.details}`;
      }
    }
    if (showRollNumbers && result.roll !== void 0) {
      const rollEl = container.createEl("p", { cls: "modal-roll-value" });
      rollEl.innerHTML = `<strong>Roll:</strong> ${result.roll}`;
    }
    if (result.nestedRolls && result.nestedRolls.length > 0) {
      const nestedHeader = container.createEl("p", {
        text: "Referenced Tables:",
        cls: "modal-nested-header"
      });
      for (const nested of result.nestedRolls) {
        const nestedDiv = container.createEl("div", { cls: "modal-nested-roll" });
        this.displayResult(nestedDiv, nested, Math.min(headingLevel + 1, 6), showRollNumbers);
      }
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ModifierPreviewModal = class extends import_obsidian.Modal {
  constructor(app, tableName, onRoll) {
    super(app);
    this.tableName = tableName;
    this.onRoll = onRoll;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Configure Roll Modifiers" });
    const infoText = contentEl.createEl("p", {
      text: "Add modifiers to dice rolls. Note: Modifiers only apply to dice-based tables (d6, d20, etc.).",
      cls: "modal-info-text"
    });
    const mainTableDiv = contentEl.createEl("div", { cls: "modal-modifier-section" });
    const mainLabel = mainTableDiv.createEl("div", { cls: "modal-modifier-label" });
    mainLabel.createEl("span", { text: `${this.tableName}` });
    const mainBadge = mainLabel.createEl("span", {
      text: " [Main Table]",
      cls: "modal-modifier-badge"
    });
    const mainInputContainer = mainTableDiv.createEl("div", { cls: "modal-input-container" });
    const mainInput = mainInputContainer.createEl("input", {
      type: "number",
      placeholder: "0",
      cls: "modal-modifier-input"
    });
    mainInput.value = "0";
    const inputHint = mainInputContainer.createEl("span", {
      text: "Modifier (e.g., +2 or -3)",
      cls: "modal-input-hint"
    });
    const noteDiv = contentEl.createEl("div", { cls: "modal-note" });
    const noteIcon = noteDiv.createEl("span", { text: "\u{1F4A1} " });
    noteDiv.createEl("span", {
      text: "Additional tables from rerolls will use this same modifier. Future updates may allow per-table modifiers for nested rolls."
    });
    const buttonDiv = contentEl.createEl("div", { cls: "modal-button-container" });
    const rollButton = buttonDiv.createEl("button", {
      text: "Roll",
      cls: "modal-button-primary"
    });
    rollButton.addEventListener("click", () => {
      const modifier = parseInt(mainInput.value) || 0;
      const tableWithModifier = modifier !== 0 ? `${this.tableName}@${modifier}` : this.tableName;
      this.onRoll(tableWithModifier);
      this.close();
    });
    const cancelButton = buttonDiv.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    mainInput.focus();
    mainInput.select();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SaveFileModal = class extends import_obsidian.Modal {
  constructor(app, defaultFilename, content) {
    super(app);
    this.defaultFilename = defaultFilename;
    this.content = content;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Save to file" });
    const inputContainer = contentEl.createEl("div", { cls: "modal-input-section" });
    const label = inputContainer.createEl("label", {
      text: "Filename:",
      cls: "modal-label"
    });
    const input = inputContainer.createEl("input", {
      type: "text",
      value: this.defaultFilename,
      cls: "modal-filename-input"
    });
    const extension = inputContainer.createEl("span", {
      text: ".md",
      cls: "modal-extension"
    });
    const buttonDiv = contentEl.createEl("div", { cls: "modal-button-container" });
    const saveButton = buttonDiv.createEl("button", { text: "Save" });
    saveButton.addEventListener("click", async () => {
      const filename = input.value.trim() || this.defaultFilename;
      await this.saveFile(filename);
      this.close();
    });
    const cancelButton = buttonDiv.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    input.focus();
    input.select();
    input.addEventListener("keypress", async (e) => {
      if (e.key === "Enter") {
        const filename = input.value.trim() || this.defaultFilename;
        await this.saveFile(filename);
        this.close();
      }
    });
  }
  async saveFile(filename) {
    const fullFilename = filename.endsWith(".md") ? filename : `${filename}.md`;
    try {
      await this.app.vault.create(fullFilename, this.content);
      console.log(`Saved roll result to ${fullFilename}`);
    } catch (error) {
      console.error("Error saving file:", error);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ErrorModal = class extends import_obsidian.Modal {
  constructor(app, title, message) {
    super(app);
    this.title = title;
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: this.title });
    const messageContainer = contentEl.createDiv({ cls: "modal-error-message" });
    messageContainer.setText(this.message);
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container modal-button-centered" });
    const closeButton = buttonContainer.createEl("button", {
      text: "OK",
      cls: "modal-button-ok"
    });
    closeButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/TableBuilderView.ts
var import_obsidian2 = require("obsidian");
var VIEW_TYPE_TABLE_BUILDER = "table-builder";
var TableBuilderView = class extends import_obsidian2.ItemView {
  constructor(leaf, roller) {
    super(leaf);
    this.hasUnsavedChanges = false;
    this.selectedRowIndex = 0;
    this.currentFile = null;
    // Track the file we loaded from
    this.activeContextMenu = null;
    // Track active context menu
    this.activeMenuCloseListener = null;
    // History for undo/redo
    this.history = [];
    this.historyIndex = -1;
    this.MAX_HISTORY = 50;
    // Debounce timer for preview updates
    this.previewUpdateTimer = null;
    // Drag and drop for columns
    this.draggedColumnIndex = -1;
    this.roller = roller;
    this.state = this.getDefaultState();
  }
  getViewType() {
    return VIEW_TYPE_TABLE_BUILDER;
  }
  getDisplayText() {
    const asterisk = this.hasUnsavedChanges ? "*" : "";
    return `Table Builder${asterisk}`;
  }
  getIcon() {
    return "table";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("table-builder-view");
    const splitContainer = container.createDiv({ cls: "table-builder-split" });
    this.leftPanel = splitContainer.createDiv({ cls: "table-builder-left-panel" });
    this.rightPanel = splitContainer.createDiv({ cls: "table-builder-right-panel" });
    this.buildLeftPanel();
    this.buildRightPanel();
    this.applyStyles();
  }
  async onClose() {
    if (this.activeContextMenu && this.activeContextMenu.parentNode) {
      try {
        this.activeContextMenu.parentNode.removeChild(this.activeContextMenu);
      } catch (e) {
      }
    }
    if (this.activeMenuCloseListener) {
      document.removeEventListener("click", this.activeMenuCloseListener);
      this.activeMenuCloseListener = null;
    }
    if (this.hasUnsavedChanges) {
      console.warn("Closing Table Builder with unsaved changes");
    }
  }
  getDefaultState() {
    return {
      tableName: "New Table",
      columns: [
        { id: "col_dice", name: "d6", type: "dice", diceNotation: "d6" },
        { id: "col_0", name: "Result", type: "regular" }
      ],
      rows: this.generateDefaultRows("d6", 6),
      isPrivate: false
    };
  }
  generateColumnId() {
    return `col_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  generateDefaultRows(diceNotation, count, groupSize, remainder) {
    const rows = [];
    const match = diceNotation.match(/^(\d*)d(\d+)$/i);
    if (!match)
      return rows;
    const numDice = match[1] ? parseInt(match[1]) : 1;
    const sides = parseInt(match[2]);
    const minValue = numDice;
    const maxValue = numDice * sides;
    const totalRange = maxValue - minValue + 1;
    if (groupSize && groupSize >= 2) {
      const extraValues = totalRange % groupSize;
      let currentValue = minValue;
      const remainderStrategy = remainder || "expand-last";
      if (remainderStrategy === "row-first" && extraValues > 0) {
        const end = minValue + extraValues - 1;
        if (minValue === end) {
          rows.push({ range: `${minValue}` });
        } else {
          rows.push({ range: `${minValue}-${end}` });
        }
        currentValue = end + 1;
      }
      const mainRowCount = Math.floor(totalRange / groupSize);
      for (let i = 0; i < mainRowCount; i++) {
        let rangeSize = groupSize;
        if (extraValues > 0) {
          if (remainderStrategy === "expand-first" && i === 0) {
            rangeSize = groupSize + extraValues;
          } else if (remainderStrategy === "expand-last" && i === mainRowCount - 1) {
            rangeSize = groupSize + extraValues;
          }
        }
        const start = currentValue;
        const end = Math.min(currentValue + rangeSize - 1, maxValue);
        if (start === end) {
          rows.push({ range: `${start}` });
        } else {
          rows.push({ range: `${start}-${end}` });
        }
        currentValue = end + 1;
      }
      if (remainderStrategy === "row-last" && extraValues > 0 && currentValue <= maxValue) {
        if (currentValue === maxValue) {
          rows.push({ range: `${maxValue}` });
        } else {
          rows.push({ range: `${currentValue}-${maxValue}` });
        }
      }
    } else if (count < totalRange) {
      const calculatedGroupSize = Math.floor(totalRange / count);
      const extraValues = totalRange % count;
      let currentValue = minValue;
      for (let i = 0; i < count; i++) {
        let rangeSize = calculatedGroupSize;
        if (i === count - 1 && extraValues > 0) {
          rangeSize = calculatedGroupSize + extraValues;
        }
        const start = currentValue;
        const end = Math.min(currentValue + rangeSize - 1, maxValue);
        if (start === end) {
          rows.push({ range: `${start}` });
        } else {
          rows.push({ range: `${start}-${end}` });
        }
        currentValue = end + 1;
      }
    } else {
      for (let i = minValue; i <= Math.min(maxValue, minValue + count - 1); i++) {
        rows.push({ range: `${i}` });
      }
    }
    return rows;
  }
  buildLeftPanel() {
    const toolbar = this.leftPanel.createDiv({ cls: "table-builder-toolbar" });
    const undoButton = toolbar.createEl("button", { text: "Undo", cls: "table-builder-btn" });
    undoButton.addEventListener("click", () => this.undo());
    const redoButton = toolbar.createEl("button", { text: "Redo", cls: "table-builder-btn" });
    redoButton.addEventListener("click", () => this.redo());
    const clearResultsBtn = toolbar.createEl("button", { text: "Clear Results", cls: "table-builder-btn" });
    clearResultsBtn.addEventListener("click", () => this.clearResults());
    const deleteAllBtn = toolbar.createEl("button", { text: "Delete All Rows", cls: "table-builder-btn" });
    deleteAllBtn.addEventListener("click", () => this.deleteAllRows());
    const nameSection = this.leftPanel.createDiv({ cls: "table-builder-section" });
    nameSection.createEl("label", { text: "Table Name:" });
    this.tableNameInput = nameSection.createEl("input", { type: "text", value: this.state.tableName });
    this.tableNameInput.addEventListener("input", () => {
      this.captureState();
      this.state.tableName = this.tableNameInput.value;
      this.markUnsaved();
      this.schedulePreviewUpdate();
    });
    const columnsSection = this.leftPanel.createDiv({ cls: "table-builder-section" });
    columnsSection.createEl("h3", { text: "Columns" });
    this.buildColumnsEditor(columnsSection);
    const directivesSection = this.leftPanel.createDiv({ cls: "table-builder-section" });
    directivesSection.createEl("h3", { text: "Directives" });
    this.buildDirectivesEditor(directivesSection);
    const rowsSection = this.leftPanel.createDiv({ cls: "table-builder-section" });
    rowsSection.createEl("h3", { text: "Rows" });
    this.rowGrid = rowsSection.createDiv({ cls: "table-builder-row-grid" });
    this.buildRowGrid();
    const addRowBtn = rowsSection.createEl("button", { text: "+ Add Row", cls: "table-builder-btn" });
    addRowBtn.addEventListener("click", () => this.addRow());
    this.buildExamplesSidebar(this.leftPanel);
  }
  buildColumnsEditor(container) {
    const columnsList = container.createDiv({ cls: "columns-list" });
    this.state.columns.forEach((col, index) => {
      const colItem = columnsList.createDiv({ cls: "column-item" });
      const dragHandle = colItem.createDiv({ cls: "drag-handle", text: "\u22EE\u22EE" });
      dragHandle.draggable = true;
      dragHandle.addEventListener("dragstart", (e) => this.onColumnDragStart(e, index));
      dragHandle.addEventListener("dragover", (e) => this.onColumnDragOver(e));
      dragHandle.addEventListener("drop", (e) => this.onColumnDrop(e, index));
      const nameInput = colItem.createEl("input", {
        type: "text",
        value: col.name,
        placeholder: "Column name"
      });
      if (col.type === "reroll") {
        nameInput.disabled = true;
        nameInput.style.opacity = "0.6";
        nameInput.style.cursor = "not-allowed";
      }
      nameInput.addEventListener("input", () => {
        this.captureState();
        col.name = nameInput.value;
        this.markUnsaved();
        this.schedulePreviewUpdate();
      });
      nameInput.addEventListener("blur", () => {
        if (col.type === "dice") {
          this.buildRowGrid();
        }
      });
      const typeLabel = colItem.createSpan({ text: `(${col.type})`, cls: "column-type" });
      if (col.type === "dice" && col.diceNotation) {
        const generateBtn = colItem.createEl("button", { text: "Generate Rows...", cls: "table-builder-btn-small" });
        generateBtn.style.marginLeft = "8px";
        generateBtn.addEventListener("click", () => this.showGenerateRowsModal(col.diceNotation));
      }
      if (this.state.columns.length > 1) {
        const deleteBtn = colItem.createEl("button", { text: "\xD7", cls: "delete-btn" });
        deleteBtn.addEventListener("click", () => this.deleteColumn(index));
      }
    });
    const addBtns = container.createDiv({ cls: "add-column-btns" });
    const hasDiceColumn = this.state.columns.some((c) => c.type === "dice");
    if (!hasDiceColumn) {
      const addDiceBtn = addBtns.createEl("button", { text: "+ Dice Column", cls: "table-builder-btn" });
      addDiceBtn.addEventListener("click", () => this.addDiceColumn());
    }
    const addRegularBtn = addBtns.createEl("button", { text: "+ Regular Column", cls: "table-builder-btn" });
    addRegularBtn.addEventListener("click", () => this.addColumn("regular"));
    const hasRerollColumn = this.state.columns.some((c) => c.type === "reroll");
    if (!hasRerollColumn) {
      const addRerollBtn = addBtns.createEl("button", { text: "+ Reroll Column", cls: "table-builder-btn" });
      addRerollBtn.addEventListener("click", () => this.addColumn("reroll"));
    }
  }
  buildDirectivesEditor(container) {
    const privateDiv = container.createDiv({ cls: "directive-item" });
    privateDiv.title = "When enabled, this table will not appear in the table picker dropdown when rolling from other tables";
    const privateLabel = privateDiv.createEl("label");
    const privateCheckbox = privateLabel.createEl("input", { type: "checkbox" });
    privateCheckbox.checked = this.state.isPrivate;
    privateLabel.appendText(" Private ");
    privateCheckbox.addEventListener("change", () => {
      this.captureState();
      this.state.isPrivate = privateCheckbox.checked;
      this.markUnsaved();
      this.schedulePreviewUpdate();
    });
    const rerollDiv = container.createDiv({ cls: "directive-item" });
    const rerollLabel = rerollDiv.createEl("label", { text: "Table-level Reroll:" });
    rerollLabel.title = "Automatically roll on additional tables after rolling this one. Use comma-separated list (Table1,Table2) or dice notation (d6 Table1), or both";
    const rerollInput = rerollDiv.createEl("input", {
      type: "text",
      placeholder: "Table1,Table2 or d6 Table1",
      value: this.state.tableReroll || ""
    });
    rerollInput.title = "Automatically roll on additional tables after rolling this one. Use comma-separated list (Table1,Table2) or dice notation (d6 Table1), or both";
    rerollInput.addEventListener("input", () => {
      this.captureState();
      this.state.tableReroll = rerollInput.value || void 0;
      this.markUnsaved();
      this.schedulePreviewUpdate();
    });
    rerollInput.addEventListener("blur", () => {
      if (this.state.tableReroll) {
        this.validateRerollReference(this.state.tableReroll);
      }
    });
  }
  buildRowGrid() {
    this.rowGrid.empty();
    const headerRow = this.rowGrid.createDiv({ cls: "row-grid-header" });
    headerRow.createDiv({ text: "", cls: "row-number" });
    this.state.columns.forEach((col, colIndex) => {
      const headerCell = headerRow.createDiv({ text: col.name, cls: "grid-cell" });
      headerCell.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        this.showColumnContextMenu(e, colIndex);
      });
      headerCell.style.cursor = "context-menu";
    });
    this.state.rows.forEach((row, rowIndex) => {
      const rowEl = this.rowGrid.createDiv({ cls: "row-grid-row" });
      if (rowIndex === this.selectedRowIndex) {
        rowEl.addClass("selected");
      }
      const rowNum = rowEl.createDiv({ text: `${rowIndex + 1}`, cls: "row-number" });
      rowNum.addEventListener("click", () => {
        this.selectedRowIndex = rowIndex;
        this.updateRowSelection();
      });
      this.state.columns.forEach((col, colIndex) => {
        const cellKey = col.type === "dice" ? "range" : col.id;
        const cellValue = row[cellKey] || "";
        const cell = rowEl.createDiv({ cls: "grid-cell" });
        const input = cell.createEl("input", {
          type: "text",
          value: cellValue,
          placeholder: col.type === "dice" ? "1-6" : "Value"
        });
        input.addEventListener("focus", () => {
          if (this.selectedRowIndex !== rowIndex) {
            this.selectedRowIndex = rowIndex;
            this.updateRowSelection();
          }
        });
        input.addEventListener("input", () => {
          row[cellKey] = input.value;
          this.markUnsaved();
          this.schedulePreviewUpdate();
        });
        input.addEventListener("blur", () => {
          this.captureState();
        });
        input.addEventListener("keydown", (e) => {
          this.handleCellKeydown(e, rowIndex, colIndex);
        });
        if (col.type === "reroll") {
          input.addEventListener("blur", () => {
            if (input.value && input.value !== "\u2014" && input.value !== "-") {
              this.validateRerollReference(input.value);
            }
          });
        }
      });
      const actionsCell = rowEl.createDiv({ cls: "row-actions" });
      const duplicateBtn = actionsCell.createEl("button", {
        text: "\u{1F4CB}",
        cls: "row-action-btn",
        attr: { "aria-label": "Duplicate row", "title": "Duplicate row" }
      });
      duplicateBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.duplicateRowAt(rowIndex);
      });
      const deleteBtn = actionsCell.createEl("button", {
        text: "\u2715",
        cls: "row-action-btn row-delete-btn",
        attr: { "aria-label": "Delete row", "title": "Delete row" }
      });
      deleteBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.deleteRowAt(rowIndex);
      });
    });
  }
  buildExamplesSidebar(container) {
    const sidebar = container.createDiv({ cls: "examples-sidebar" });
    const toggle = sidebar.createEl("details");
    toggle.createEl("summary", { text: "Examples & Templates" });
    const content = toggle.createDiv({ cls: "examples-content" });
    content.createEl("h4", { text: "Presets" });
    const examples = [
      { name: "Individual d6 (6 rows)", dice: "d6", count: 6 },
      { name: "Individual d20 (20 rows)", dice: "d20", count: 20 },
      { name: "Range d100 (10 rows)", dice: "d100", count: 10 },
      { name: "Weighted d100 (20 rows)", dice: "d100", count: 20 }
    ];
    examples.forEach((example) => {
      const btn = content.createEl("button", {
        text: example.name,
        cls: "example-btn"
      });
      btn.addEventListener("click", () => this.applyExample(example.dice, example.count));
    });
    content.createEl("h4", { text: "Custom Templates" });
    content.createEl("p", { text: "No templates saved yet.", cls: "placeholder-text" });
    const saveTemplateBtn = content.createEl("button", {
      text: "Save as Template",
      cls: "table-builder-btn"
    });
    saveTemplateBtn.addEventListener("click", () => this.saveAsTemplate());
  }
  buildRightPanel() {
    const tabs = this.rightPanel.createDiv({ cls: "preview-tabs" });
    const markdownTab = tabs.createEl("button", { text: "Markdown", cls: "tab-btn active" });
    const htmlTab = tabs.createEl("button", { text: "Preview", cls: "tab-btn" });
    this.previewContainer = this.rightPanel.createDiv({ cls: "preview-container" });
    this.markdownPreview = this.previewContainer.createDiv({ cls: "markdown-preview active" });
    this.htmlPreview = this.previewContainer.createDiv({ cls: "html-preview" });
    markdownTab.addEventListener("click", () => {
      markdownTab.addClass("active");
      htmlTab.removeClass("active");
      this.markdownPreview.addClass("active");
      this.htmlPreview.removeClass("active");
    });
    htmlTab.addEventListener("click", () => {
      htmlTab.addClass("active");
      markdownTab.removeClass("active");
      this.htmlPreview.addClass("active");
      this.markdownPreview.removeClass("active");
    });
    const exportBtns = this.rightPanel.createDiv({ cls: "export-buttons" });
    const copyBtn = exportBtns.createEl("button", { text: "Copy to Clipboard", cls: "table-builder-btn" });
    copyBtn.addEventListener("click", () => this.copyToClipboard());
    const saveBtn = exportBtns.createEl("button", { text: "Save", cls: "table-builder-btn" });
    saveBtn.addEventListener("click", async () => await this.save());
    const saveAsBtn = exportBtns.createEl("button", { text: "Save As...", cls: "table-builder-btn" });
    saveAsBtn.addEventListener("click", async () => await this.saveAs());
    const loadBtn = exportBtns.createEl("button", { text: "Load Table", cls: "table-builder-btn" });
    loadBtn.addEventListener("click", () => this.loadTable());
    const importBtn = exportBtns.createEl("button", { text: "Import from Clipboard", cls: "table-builder-btn" });
    importBtn.addEventListener("click", () => this.importFromClipboard());
    const exportDropdown = exportBtns.createEl("select", { cls: "export-format" });
    exportDropdown.createEl("option", { text: "Markdown", value: "md" });
    exportDropdown.createEl("option", { text: "CSV", value: "csv" });
    exportDropdown.createEl("option", { text: "JSON", value: "json" });
    const exportFileBtn = exportBtns.createEl("button", { text: "Export As...", cls: "table-builder-btn" });
    exportFileBtn.addEventListener("click", () => {
      const format = exportDropdown.value;
      this.exportAs(format);
    });
    this.updatePreview();
  }
  schedulePreviewUpdate() {
    if (this.previewUpdateTimer) {
      clearTimeout(this.previewUpdateTimer);
    }
    this.previewUpdateTimer = setTimeout(() => {
      this.updatePreview();
    }, 300);
  }
  updatePreview() {
    const markdown = this.generateMarkdown();
    this.markdownPreview.empty();
    const pre = this.markdownPreview.createEl("pre");
    pre.createEl("code", { text: markdown });
    this.htmlPreview.empty();
    this.renderHTMLPreview(this.htmlPreview);
  }
  generateMarkdown() {
    const lines = [];
    lines.push("---");
    lines.push("table-roller: true");
    lines.push("---");
    lines.push("");
    lines.push(`# ${this.state.tableName}`);
    lines.push("");
    if (this.state.isPrivate) {
      lines.push("private: true");
    }
    if (this.state.tableReroll) {
      lines.push(`reroll: ${this.state.tableReroll}`);
    }
    if (this.state.isPrivate || this.state.tableReroll) {
      lines.push("");
    }
    const headers = this.state.columns.map((col) => col.name);
    lines.push("| " + headers.join(" | ") + " |");
    lines.push("|" + headers.map(() => "----").join("|") + "|");
    this.state.rows.forEach((row) => {
      const cells = this.state.columns.map((col) => {
        const key = col.type === "dice" ? "range" : col.id;
        return row[key] || "";
      });
      lines.push("| " + cells.join(" | ") + " |");
    });
    return lines.join("\n");
  }
  renderHTMLPreview(container) {
    container.createEl("h2", { text: this.state.tableName });
    if (this.state.isPrivate || this.state.tableReroll) {
      const info = container.createDiv({ cls: "directives-info" });
      if (this.state.isPrivate) {
        info.createSpan({ text: "\u{1F512} Private", cls: "badge" });
      }
      if (this.state.tableReroll) {
        info.createSpan({ text: `\u21BB Rerolls: ${this.state.tableReroll}`, cls: "badge" });
      }
    }
    const table = container.createEl("table", { cls: "preview-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    this.state.columns.forEach((col) => {
      headerRow.createEl("th", { text: col.name });
    });
    const tbody = table.createEl("tbody");
    this.state.rows.forEach((row) => {
      const tr = tbody.createEl("tr");
      this.state.columns.forEach((col) => {
        const key = col.type === "dice" ? "range" : col.id;
        tr.createEl("td", { text: row[key] || "" });
      });
    });
  }
  // History management
  captureState() {
    if (this.historyIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.historyIndex + 1);
    }
    const stateCopy = JSON.parse(JSON.stringify(this.state));
    this.history.push({
      state: stateCopy,
      timestamp: Date.now()
    });
    if (this.history.length > this.MAX_HISTORY) {
      this.history.shift();
    } else {
      this.historyIndex++;
    }
  }
  undo() {
    if (this.historyIndex > 0) {
      this.historyIndex--;
      this.state = JSON.parse(JSON.stringify(this.history[this.historyIndex].state));
      this.refreshUI();
      this.markUnsaved();
    }
  }
  redo() {
    if (this.historyIndex < this.history.length - 1) {
      this.historyIndex++;
      this.state = JSON.parse(JSON.stringify(this.history[this.historyIndex].state));
      this.refreshUI();
      this.markUnsaved();
    }
  }
  refreshUI() {
    this.tableNameInput.value = this.state.tableName;
    this.buildRowGrid();
    this.updatePreview();
  }
  // Column operations
  addDiceColumn() {
    if (this.state.columns.some((c) => c.type === "dice")) {
      new import_obsidian2.Notice("Only one dice column is allowed");
      return;
    }
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText("Add Dice Column");
    modal.contentEl.createEl("label", { text: "Select dice type:" });
    const select = modal.contentEl.createEl("select");
    select.style.width = "100%";
    select.style.padding = "8px";
    select.style.marginTop = "8px";
    select.style.marginBottom = "12px";
    const diceOptions = ["d4", "d6", "d8", "d10", "d12", "d20", "d100", "custom"];
    diceOptions.forEach((dice) => {
      select.createEl("option", { text: dice === "custom" ? "Custom..." : dice, value: dice });
    });
    const customContainer = modal.contentEl.createDiv();
    customContainer.style.marginBottom = "12px";
    customContainer.style.display = "none";
    customContainer.createEl("label", { text: "Custom dice notation (e.g., d6, 2d6, d100):" });
    const customInput = customContainer.createEl("input", {
      type: "text",
      placeholder: "d6"
    });
    customInput.style.width = "100%";
    customInput.style.padding = "8px";
    customInput.style.marginTop = "4px";
    select.addEventListener("change", () => {
      if (select.value === "custom") {
        customContainer.style.display = "block";
        customInput.focus();
      } else {
        customContainer.style.display = "none";
      }
    });
    const btnContainer = modal.contentEl.createDiv();
    btnContainer.style.display = "flex";
    btnContainer.style.justifyContent = "flex-end";
    btnContainer.style.gap = "8px";
    const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.close());
    const addBtn = btnContainer.createEl("button", { text: "Add" });
    addBtn.addEventListener("click", () => {
      let diceType = select.value;
      if (diceType === "custom") {
        diceType = customInput.value.trim().toLowerCase();
        if (!diceType) {
          new import_obsidian2.Notice("Please enter a dice notation");
          return;
        }
        if (!/^\d*d\d+$/.test(diceType)) {
          new import_obsidian2.Notice("Invalid dice notation. Use format like: d6, 2d6, d100");
          return;
        }
      }
      this.captureState();
      this.state.columns.unshift({
        id: this.generateColumnId(),
        name: diceType,
        type: "dice",
        diceNotation: diceType
      });
      this.markUnsaved();
      this.leftPanel.empty();
      this.buildLeftPanel();
      this.schedulePreviewUpdate();
      modal.close();
    });
    modal.open();
  }
  addColumn(type) {
    if (type === "reroll" && this.state.columns.some((c) => c.type === "reroll")) {
      new import_obsidian2.Notice("Only one reroll column is allowed");
      return;
    }
    this.captureState();
    const name = type === "reroll" ? "reroll" : `Column ${this.state.columns.length}`;
    const id = this.generateColumnId();
    this.state.columns.push({ id, name, type });
    this.markUnsaved();
    this.leftPanel.empty();
    this.buildLeftPanel();
    this.schedulePreviewUpdate();
  }
  deleteColumn(index) {
    if (this.state.columns.length <= 1) {
      new import_obsidian2.Notice("Cannot delete the last column");
      return;
    }
    this.captureState();
    const col = this.state.columns[index];
    this.state.columns.splice(index, 1);
    const key = col.type === "dice" ? "range" : col.id;
    this.state.rows.forEach((row) => {
      delete row[key];
    });
    this.markUnsaved();
    this.leftPanel.empty();
    this.buildLeftPanel();
    this.schedulePreviewUpdate();
  }
  // Row operations
  addRow() {
    this.captureState();
    this.state.rows.push({});
    this.markUnsaved();
    this.buildRowGrid();
    this.schedulePreviewUpdate();
  }
  duplicateRowAt(index) {
    if (this.state.rows.length === 0)
      return;
    this.captureState();
    const row = this.state.rows[index];
    const copy = JSON.parse(JSON.stringify(row));
    this.state.rows.splice(index + 1, 0, copy);
    this.selectedRowIndex = index + 1;
    this.markUnsaved();
    this.buildRowGrid();
    this.schedulePreviewUpdate();
  }
  deleteRowAt(index) {
    if (this.state.rows.length === 0)
      return;
    this.captureState();
    this.state.rows.splice(index, 1);
    if (this.selectedRowIndex >= this.state.rows.length && this.selectedRowIndex > 0) {
      this.selectedRowIndex--;
    }
    if (index === this.selectedRowIndex && this.state.rows.length > 0) {
      this.selectedRowIndex = Math.min(index, this.state.rows.length - 1);
    }
    this.markUnsaved();
    this.buildRowGrid();
    this.schedulePreviewUpdate();
  }
  clearResults() {
    this.captureState();
    this.state.rows.forEach((row) => {
      this.state.columns.forEach((col) => {
        if (col.type === "regular") {
          row[col.id] = "";
        }
      });
    });
    this.markUnsaved();
    this.buildRowGrid();
    this.schedulePreviewUpdate();
  }
  deleteAllRows() {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText("Delete All Rows?");
    modal.contentEl.setText("This will delete all rows. Do you want to proceed?.");
    const btnContainer = modal.contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.close());
    const confirmBtn = btnContainer.createEl("button", { text: "Delete All", cls: "mod-warning" });
    confirmBtn.addEventListener("click", () => {
      this.captureState();
      this.state.rows = [];
      this.selectedRowIndex = 0;
      this.markUnsaved();
      this.buildRowGrid();
      this.schedulePreviewUpdate();
      modal.close();
    });
    modal.open();
  }
  // Keyboard navigation
  handleCellKeydown(e, rowIndex, colIndex) {
    const rows = this.state.rows.length;
    const cols = this.state.columns.length;
    let newRow = rowIndex;
    let newCol = colIndex;
    let shouldMove = false;
    if (e.key === "Tab") {
      e.preventDefault();
      if (e.shiftKey) {
        newCol--;
        if (newCol < 0) {
          newCol = cols - 1;
          newRow--;
        }
      } else {
        newCol++;
        if (newCol >= cols) {
          newCol = 0;
          newRow++;
        }
      }
      shouldMove = true;
    } else if (e.key === "Enter") {
      e.preventDefault();
      if (e.shiftKey) {
        newRow--;
      } else {
        newRow++;
      }
      shouldMove = true;
    }
    if (shouldMove && newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
      this.selectedRowIndex = newRow;
      setTimeout(() => {
        const rowEls = this.rowGrid.querySelectorAll(".row-grid-row");
        const rowEl = rowEls[newRow];
        const inputs = rowEl.querySelectorAll("input");
        const input = inputs[newCol];
        if (input) {
          input.focus();
          input.select();
        }
      }, 0);
    }
  }
  updateRowSelection() {
    const rowEls = this.rowGrid.querySelectorAll(".row-grid-row");
    rowEls.forEach((el, idx) => {
      if (idx === this.selectedRowIndex) {
        el.addClass("selected");
      } else {
        el.removeClass("selected");
      }
    });
  }
  onColumnDragStart(e, index) {
    this.draggedColumnIndex = index;
    if (e.dataTransfer) {
      e.dataTransfer.effectAllowed = "move";
    }
  }
  onColumnDragOver(e) {
    e.preventDefault();
    if (e.dataTransfer) {
      e.dataTransfer.dropEffect = "move";
    }
  }
  onColumnDrop(e, targetIndex) {
    e.preventDefault();
    if (this.draggedColumnIndex === targetIndex)
      return;
    this.captureState();
    const [moved] = this.state.columns.splice(this.draggedColumnIndex, 1);
    this.state.columns.splice(targetIndex, 0, moved);
    this.draggedColumnIndex = -1;
    this.markUnsaved();
    this.leftPanel.empty();
    this.buildLeftPanel();
    this.schedulePreviewUpdate();
  }
  // Column operations
  showColumnContextMenu(e, colIndex) {
    if (this.activeMenuCloseListener) {
      document.removeEventListener("click", this.activeMenuCloseListener);
      this.activeMenuCloseListener = null;
    }
    if (this.activeContextMenu) {
      try {
        if (this.activeContextMenu.parentNode) {
          this.activeContextMenu.parentNode.removeChild(this.activeContextMenu);
        }
      } catch (e2) {
      }
      this.activeContextMenu = null;
    }
    const menu = document.createElement("div");
    menu.className = "column-context-menu";
    menu.style.position = "fixed";
    menu.style.left = `${e.clientX}px`;
    menu.style.top = `${e.clientY}px`;
    menu.style.zIndex = "10000";
    menu.style.background = "var(--background-secondary)";
    menu.style.border = "1px solid var(--background-modifier-border)";
    menu.style.borderRadius = "4px";
    menu.style.padding = "4px";
    menu.style.minWidth = "150px";
    const pasteOption = menu.createEl("div", {
      text: "Paste into column",
      cls: "context-menu-item"
    });
    pasteOption.style.padding = "6px 12px";
    pasteOption.style.cursor = "pointer";
    pasteOption.addEventListener("mouseenter", () => {
      pasteOption.style.background = "var(--background-modifier-hover)";
    });
    pasteOption.addEventListener("mouseleave", () => {
      pasteOption.style.background = "";
    });
    pasteOption.addEventListener("click", async () => {
      if (this.activeMenuCloseListener) {
        document.removeEventListener("click", this.activeMenuCloseListener);
        this.activeMenuCloseListener = null;
      }
      await this.pasteIntoColumn(colIndex);
      if (menu.parentNode && document.body.contains(menu)) {
        try {
          menu.parentNode.removeChild(menu);
        } catch (e2) {
        }
      }
      this.activeContextMenu = null;
    });
    document.body.appendChild(menu);
    this.activeContextMenu = menu;
    const closeMenu = (event) => {
      if (!menu.contains(event.target)) {
        document.removeEventListener("click", closeMenu);
        this.activeMenuCloseListener = null;
        if (document.body.contains(menu)) {
          try {
            document.body.removeChild(menu);
          } catch (error) {
          }
        }
        if (this.activeContextMenu === menu) {
          this.activeContextMenu = null;
        }
      }
    };
    this.activeMenuCloseListener = closeMenu;
    setTimeout(() => {
      if (this.activeContextMenu === menu) {
        document.addEventListener("click", closeMenu);
      }
    }, 0);
  }
  async pasteIntoColumn(colIndex) {
    try {
      const text = await navigator.clipboard.readText();
      if (!text.trim()) {
        new import_obsidian2.Notice("Clipboard is empty");
        return;
      }
      let values;
      if (text.includes("	")) {
        const rows = text.split(/\r?\n/).filter((r) => r.trim());
        values = rows.map((row) => row.split("	")[0].trim());
      } else if (text.includes(",") && !text.includes("\n")) {
        values = text.split(",").map((v) => v.trim()).filter((v) => v);
      } else {
        values = text.split(/\r?\n/).map((v) => v.trim()).filter((v) => v);
      }
      if (values.length === 0) {
        new import_obsidian2.Notice("No valid data to paste");
        return;
      }
      this.captureState();
      const col = this.state.columns[colIndex];
      const cellKey = col.type === "dice" ? "range" : col.id;
      const rowsNeeded = values.length;
      this.markUnsaved();
      this.buildRowGrid();
      this.schedulePreviewUpdate();
      new import_obsidian2.Notice(`Pasted ${values.length} values into ${col.name}`);
    } catch (error) {
      console.error("Error pasting into column:", error);
      new import_obsidian2.Notice("Failed to paste from clipboard");
    }
  }
  // Examples
  applyExample(diceNotation, rowCount) {
    var _a;
    this.captureState();
    this.state.columns[0] = {
      id: ((_a = this.state.columns[0]) == null ? void 0 : _a.id) || this.generateColumnId(),
      name: diceNotation,
      type: "dice",
      diceNotation
    };
    this.state.rows = this.generateDefaultRows(diceNotation, rowCount);
    this.markUnsaved();
    this.leftPanel.empty();
    this.buildLeftPanel();
    this.schedulePreviewUpdate();
    new import_obsidian2.Notice(`Applied ${diceNotation} with ${rowCount} rows`);
  }
  generateRows(diceNotation, rowCount, groupSize, remainder) {
    this.captureState();
    this.state.rows = this.generateDefaultRows(diceNotation, rowCount, groupSize, remainder);
    this.markUnsaved();
    this.buildRowGrid();
    this.schedulePreviewUpdate();
    new import_obsidian2.Notice(`Generated ${rowCount} rows for ${diceNotation}`);
  }
  showGenerateRowsModal(diceNotation) {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText(`Generate Rows for ${diceNotation}`);
    const match = diceNotation.match(/^(\d*)d(\d+)$/i);
    if (!match) {
      new import_obsidian2.Notice("Invalid dice notation");
      return;
    }
    const numDice = match[1] ? parseInt(match[1]) : 1;
    const sides = parseInt(match[2]);
    const minValue = numDice;
    const maxValue = numDice * sides;
    const totalRange = maxValue - minValue + 1;
    const generateOptions = [];
    generateOptions.push({ name: `All values (${totalRange} rows)`, count: totalRange });
    const commonGroupSizes = [2, 3, 5, 10];
    for (const groupSize of commonGroupSizes) {
      if (groupSize < totalRange) {
        const rowCount = Math.ceil(totalRange / groupSize);
        generateOptions.push({ name: `Every ${groupSize} (~${rowCount} rows)`, count: rowCount, groupSize });
      }
    }
    const formContainer = modal.contentEl.createDiv();
    formContainer.style.marginBottom = "12px";
    const optionLabel = formContainer.createEl("label", { text: "Range option:" });
    optionLabel.style.display = "block";
    optionLabel.style.marginBottom = "4px";
    const optionSelect = formContainer.createEl("select");
    optionSelect.style.width = "100%";
    optionSelect.style.padding = "8px";
    optionSelect.style.marginBottom = "12px";
    generateOptions.forEach((option) => {
      optionSelect.createEl("option", {
        text: option.name,
        value: option.groupSize ? option.groupSize.toString() : "all"
      });
    });
    optionSelect.createEl("option", { text: "Custom", value: "custom" });
    const customInputContainer = formContainer.createDiv();
    customInputContainer.style.display = "none";
    customInputContainer.style.marginBottom = "12px";
    const customLabel = customInputContainer.createEl("label", { text: "Range (values per row):" });
    customLabel.style.display = "block";
    customLabel.style.marginBottom = "4px";
    const customInput = customInputContainer.createEl("input", {
      type: "number",
      placeholder: "2",
      attr: { min: "2", max: totalRange.toString() }
    });
    customInput.style.width = "100%";
    customInput.style.padding = "8px";
    optionSelect.addEventListener("change", () => {
      customInputContainer.style.display = optionSelect.value === "custom" ? "block" : "none";
    });
    const remainderContainer = formContainer.createDiv();
    remainderContainer.style.marginBottom = "12px";
    const remainderLabel = remainderContainer.createEl("label", { text: "Handle remainder:" });
    remainderLabel.style.display = "block";
    remainderLabel.style.marginBottom = "4px";
    const remainderSelect = remainderContainer.createEl("select");
    remainderSelect.style.width = "100%";
    remainderSelect.style.padding = "8px";
    remainderSelect.createEl("option", { text: "Expand first row (add to first range)", value: "expand-first" });
    remainderSelect.createEl("option", { text: "Expand last row (add to last range)", value: "expand-last", attr: { selected: "selected" } });
    remainderSelect.createEl("option", { text: "Additional row at start", value: "row-first" });
    remainderSelect.createEl("option", { text: "Additional row at end", value: "row-last" });
    const generateBtn = formContainer.createEl("button", {
      text: "Generate",
      cls: "table-builder-btn"
    });
    generateBtn.style.width = "100%";
    generateBtn.addEventListener("click", () => {
      const selectedValue = optionSelect.value;
      let groupSize;
      if (selectedValue === "all") {
        groupSize = void 0;
      } else if (selectedValue === "custom") {
        groupSize = parseInt(customInput.value);
        if (!groupSize || groupSize < 2) {
          new import_obsidian2.Notice("Range must be at least 2");
          return;
        }
        if (groupSize > totalRange) {
          new import_obsidian2.Notice(`Range cannot exceed total range (${totalRange})`);
          return;
        }
      } else {
        groupSize = parseInt(selectedValue);
      }
      const remainder = remainderSelect.value;
      const rowCount = groupSize ? Math.ceil(totalRange / groupSize) : totalRange;
      this.generateRows(diceNotation, rowCount, groupSize, remainder);
      modal.close();
    });
    modal.open();
  }
  // Template operations
  async saveAsTemplate() {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText("Save as Template");
    const input = modal.contentEl.createEl("input", {
      type: "text",
      placeholder: "Template name",
      value: this.state.tableName + " Template"
    });
    input.style.width = "100%";
    input.style.padding = "8px";
    input.style.marginBottom = "12px";
    const btnContainer = modal.contentEl.createDiv();
    btnContainer.style.display = "flex";
    btnContainer.style.justifyContent = "flex-end";
    btnContainer.style.gap = "8px";
    const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.close());
    const saveBtn = btnContainer.createEl("button", { text: "Save" });
    saveBtn.addEventListener("click", async () => {
      const templateName = input.value.trim();
      if (!templateName) {
        new import_obsidian2.Notice("Template name cannot be empty");
        return;
      }
      await this.saveTemplate(templateName);
      modal.close();
    });
    input.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        saveBtn.click();
      }
    });
    modal.open();
    input.focus();
  }
  async saveTemplate(templateName) {
    try {
      const templatesFolder = ".table-templates";
      const folder = this.app.vault.getAbstractFileByPath(templatesFolder);
      if (!folder) {
        await this.app.vault.createFolder(templatesFolder);
      }
      const templateState = {
        tableName: templateName,
        columns: JSON.parse(JSON.stringify(this.state.columns)),
        rows: this.state.rows.map(() => ({})),
        // Empty rows with same count
        isPrivate: this.state.isPrivate,
        tableReroll: this.state.tableReroll
      };
      const lines = [];
      lines.push("---");
      lines.push("table-roller-template: true");
      lines.push("---");
      lines.push("");
      lines.push(`# ${templateName}`);
      lines.push("");
      lines.push("```json");
      lines.push(JSON.stringify(templateState, null, 2));
      lines.push("```");
      const filename = `${templatesFolder}/${templateName}.md`;
      await this.app.vault.create(filename, lines.join("\n"));
      new import_obsidian2.Notice(`Template saved: ${templateName}`);
    } catch (error) {
      console.error("Error saving template:", error);
      new import_obsidian2.Notice("Failed to save template");
    }
  }
  // Import/Export
  async importFromClipboard() {
    try {
      const text = await navigator.clipboard.readText();
      const lines = text.split("\n").filter((l) => l.trim().includes("|"));
      if (lines.length < 2) {
        new import_obsidian2.Notice("No valid table found in clipboard");
        return;
      }
      const headerLine = lines[0];
      const headers = headerLine.split("|").map((h) => h.trim()).filter((h) => h.length > 0);
      if (headers.length === 0) {
        new import_obsidian2.Notice("Could not parse table headers");
        return;
      }
      const columns = headers.map((h, idx) => {
        const id = this.generateColumnId();
        if (/^\d*d\d+$/i.test(h.trim())) {
          return { id, name: h, type: "dice", diceNotation: h.toLowerCase() };
        } else if (/^reroll$/i.test(h.trim())) {
          return { id, name: h, type: "reroll" };
        } else {
          return { id, name: h, type: "regular" };
        }
      });
      const rows = [];
      for (let i = 2; i < lines.length; i++) {
        const cells = lines[i].split("|").map((c) => c.trim()).filter((_, idx) => idx > 0 && idx <= headers.length);
        if (cells.length > 0) {
          const row = {};
          headers.forEach((header, idx) => {
            const col = columns[idx];
            const key = col.type === "dice" ? "range" : col.id;
            row[key] = cells[idx] || "";
          });
          rows.push(row);
        }
      }
      this.captureState();
      this.state.columns = columns;
      this.state.rows = rows;
      this.markUnsaved();
      this.leftPanel.empty();
      this.buildLeftPanel();
      this.schedulePreviewUpdate();
      new import_obsidian2.Notice("Table imported from clipboard");
    } catch (error) {
      console.error("Import error:", error);
      new import_obsidian2.Notice("Failed to import from clipboard");
    }
  }
  async copyToClipboard() {
    const markdown = this.generateMarkdown();
    await navigator.clipboard.writeText(markdown);
    new import_obsidian2.Notice("Copied to clipboard");
  }
  async save() {
    if (!await this.validate()) {
      return;
    }
    if (this.currentFile) {
      await this.saveToCurrentFile();
      return;
    }
    await this.saveAs();
  }
  async saveAs() {
    if (!await this.validate()) {
      return;
    }
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText("Save Table As");
    const createNewBtn = modal.contentEl.createEl("button", {
      text: "Create New File",
      cls: "table-builder-btn"
    });
    createNewBtn.style.width = "100%";
    createNewBtn.style.marginBottom = "8px";
    createNewBtn.addEventListener("click", () => {
      modal.close();
      this.saveToNewFile();
    });
    const appendBtn = modal.contentEl.createEl("button", {
      text: "Append to Existing File",
      cls: "table-builder-btn"
    });
    appendBtn.style.width = "100%";
    appendBtn.addEventListener("click", () => {
      modal.close();
      this.appendToFile();
    });
    modal.open();
  }
  async saveToNewFile() {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText("Save to New File");
    const input = modal.contentEl.createEl("input", {
      type: "text",
      placeholder: "Filename (without .md)",
      value: this.state.tableName
    });
    input.style.width = "100%";
    input.style.padding = "8px";
    input.style.marginBottom = "12px";
    const btnContainer = modal.contentEl.createDiv();
    btnContainer.style.display = "flex";
    btnContainer.style.justifyContent = "flex-end";
    btnContainer.style.gap = "8px";
    const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.close());
    const saveBtn = btnContainer.createEl("button", { text: "Save" });
    saveBtn.addEventListener("click", async () => {
      const filename = input.value.trim();
      if (!filename) {
        new import_obsidian2.Notice("Filename cannot be empty");
        return;
      }
      const fullFilename = filename.endsWith(".md") ? filename : `${filename}.md`;
      const markdown = this.generateMarkdown();
      try {
        const file = await this.app.vault.create(fullFilename, markdown);
        new import_obsidian2.Notice(`Saved to ${fullFilename}`);
        this.currentFile = file;
        this.hasUnsavedChanges = false;
        await this.roller.loadTables();
        modal.close();
      } catch (error) {
        console.error("Error saving file:", error);
        new import_obsidian2.Notice("Failed to save file");
      }
    });
    input.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        saveBtn.click();
      }
    });
    modal.open();
    input.focus();
  }
  async appendToFile() {
    const files = this.app.vault.getMarkdownFiles().filter((f) => !f.path.startsWith(".table-templates/"));
    if (files.length === 0) {
      new import_obsidian2.Notice("No markdown files found");
      return;
    }
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText("Select File to Append To");
    const searchInput = modal.contentEl.createEl("input", {
      type: "text",
      placeholder: "Search files..."
    });
    searchInput.style.width = "100%";
    searchInput.style.padding = "8px";
    searchInput.style.marginBottom = "12px";
    searchInput.style.fontSize = "14px";
    const fileList = modal.contentEl.createDiv({ cls: "file-list" });
    fileList.style.maxHeight = "400px";
    fileList.style.overflowY = "auto";
    let fileButtons = [];
    const renderFiles = (searchTerm = "") => {
      fileList.empty();
      fileButtons = [];
      let filteredFiles = files;
      if (searchTerm) {
        const lower = searchTerm.toLowerCase();
        filteredFiles = files.filter((f) => f.path.toLowerCase().includes(lower)).sort((a, b) => {
          const aStarts = a.basename.toLowerCase().startsWith(lower);
          const bStarts = b.basename.toLowerCase().startsWith(lower);
          if (aStarts && !bStarts)
            return -1;
          if (!aStarts && bStarts)
            return 1;
          const aIndex = a.path.toLowerCase().indexOf(lower);
          const bIndex = b.path.toLowerCase().indexOf(lower);
          if (aIndex !== bIndex)
            return aIndex - bIndex;
          return a.path.localeCompare(b.path);
        });
      } else {
        filteredFiles = [...files].sort((a, b) => a.path.localeCompare(b.path));
      }
      if (filteredFiles.length === 0) {
        const noResults = fileList.createDiv({ text: "No files match your search" });
        noResults.style.padding = "16px";
        noResults.style.textAlign = "center";
        noResults.style.color = "var(--text-muted)";
        return;
      }
      filteredFiles.forEach((file) => {
        const fileBtn = fileList.createEl("button", {
          text: file.path,
          cls: "file-option"
        });
        fileBtn.style.display = "block";
        fileBtn.style.width = "100%";
        fileBtn.style.textAlign = "left";
        fileBtn.style.padding = "8px";
        fileBtn.style.marginBottom = "4px";
        fileBtn.style.border = "1px solid var(--background-modifier-border)";
        fileBtn.style.background = "var(--background-secondary)";
        fileBtn.style.cursor = "pointer";
        fileBtn.addEventListener("click", async () => {
          modal.close();
          await this.appendToSpecificFile(file);
        });
        fileBtn.addEventListener("mouseenter", () => {
          fileBtn.style.background = "var(--background-modifier-hover)";
        });
        fileBtn.addEventListener("mouseleave", () => {
          fileBtn.style.background = "var(--background-secondary)";
        });
        fileButtons.push({ button: fileBtn, file });
      });
    };
    renderFiles();
    searchInput.addEventListener("input", () => {
      renderFiles(searchInput.value);
    });
    searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && fileButtons.length > 0) {
        modal.close();
        this.appendToSpecificFile(fileButtons[0].file);
      }
    });
    modal.open();
    setTimeout(() => searchInput.focus(), 50);
  }
  async appendToSpecificFile(file) {
    try {
      const currentContent = await this.app.vault.read(file);
      const markdown = this.generateMarkdown();
      const lines = markdown.split("\n");
      const tableStartIndex = lines.findIndex((l) => l.startsWith("#"));
      const tableContent = lines.slice(tableStartIndex).join("\n");
      const newContent = currentContent + "\n\n" + tableContent;
      await this.app.vault.modify(file, newContent);
      new import_obsidian2.Notice(`Appended to ${file.path}`);
      this.currentFile = file;
      this.hasUnsavedChanges = false;
      await this.roller.loadTables();
    } catch (error) {
      console.error("Error appending to file:", error);
      new import_obsidian2.Notice("Failed to append to file");
    }
  }
  async loadTable() {
    const files = this.app.vault.getMarkdownFiles().filter((f) => !f.path.startsWith(".table-templates/"));
    if (files.length === 0) {
      new import_obsidian2.Notice("No markdown files found");
      return;
    }
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText("Load Table from File");
    const fileList = modal.contentEl.createDiv({ cls: "file-list" });
    fileList.style.maxHeight = "400px";
    fileList.style.overflowY = "auto";
    files.forEach((file) => {
      const fileBtn = fileList.createEl("button", {
        text: file.path,
        cls: "file-option"
      });
      fileBtn.style.display = "block";
      fileBtn.style.width = "100%";
      fileBtn.style.textAlign = "left";
      fileBtn.style.padding = "8px";
      fileBtn.style.marginBottom = "4px";
      fileBtn.style.border = "1px solid var(--background-modifier-border)";
      fileBtn.style.background = "var(--background-secondary)";
      fileBtn.style.cursor = "pointer";
      fileBtn.addEventListener("click", async () => {
        modal.close();
        await this.loadFromFile(file);
      });
      fileBtn.addEventListener("mouseenter", () => {
        fileBtn.style.background = "var(--background-modifier-hover)";
      });
      fileBtn.addEventListener("mouseleave", () => {
        fileBtn.style.background = "var(--background-secondary)";
      });
    });
    modal.open();
  }
  async loadFromFile(file) {
    try {
      this.currentFile = file;
      const content = await this.app.vault.read(file);
      const parsed = TableParser.parseTables(content, file.basename);
      const tableNames = Object.keys(parsed.tables);
      if (tableNames.length === 0) {
        new import_obsidian2.Notice("No tables found in file");
        return;
      }
      if (tableNames.length === 1 && tableNames[0] === file.basename) {
        await this.loadParsedTable(tableNames[0], parsed.tables[tableNames[0]], parsed);
      } else {
        this.showTablePicker(tableNames, parsed, file);
      }
    } catch (error) {
      console.error("Error loading table:", error);
      new import_obsidian2.Notice("Failed to load table");
    }
  }
  showTablePicker(tableNames, parsed, file) {
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText(`Select Table from ${file.basename}`);
    modal.contentEl.createEl("p", {
      text: `This file contains ${tableNames.length} table${tableNames.length > 1 ? "s" : ""}:`,
      cls: "table-picker-hint"
    });
    const tableList = modal.contentEl.createDiv({ cls: "table-list" });
    tableList.style.maxHeight = "500px";
    tableList.style.overflowY = "auto";
    tableList.style.minWidth = "400px";
    tableNames.forEach((name) => {
      const table = parsed.tables[name];
      const isDiceTable = "dice" in table;
      const entryCount = isDiceTable ? table.entries.length : table.rows.length;
      const tableType = isDiceTable ? `Dice (${table.dice})` : "Simple";
      const btn = tableList.createEl("button", {
        cls: "table-option"
      });
      btn.style.display = "block";
      btn.style.width = "100%";
      btn.style.textAlign = "left";
      btn.style.padding = "12px";
      btn.style.marginBottom = "8px";
      btn.style.border = "1px solid var(--background-modifier-border)";
      btn.style.background = "var(--background-secondary)";
      btn.style.cursor = "pointer";
      btn.style.minHeight = "60px";
      const nameEl = btn.createEl("div", { text: name });
      nameEl.style.fontWeight = "bold";
      nameEl.style.marginBottom = "4px";
      nameEl.style.overflow = "hidden";
      nameEl.style.textOverflow = "ellipsis";
      nameEl.style.whiteSpace = "normal";
      nameEl.style.wordBreak = "break-word";
      nameEl.style.marginBottom = "4px";
      const infoEl = btn.createEl("div", {
        text: `${tableType} \u2022 ${entryCount} rows`,
        cls: "table-info"
      });
      infoEl.style.fontSize = "0.9em";
      infoEl.style.opacity = "0.7";
      btn.addEventListener("click", async () => {
        modal.close();
        await this.loadParsedTable(name, table, parsed);
      });
      btn.addEventListener("mouseenter", () => {
        btn.style.background = "var(--background-modifier-hover)";
      });
      btn.addEventListener("mouseleave", () => {
        btn.style.background = "var(--background-secondary)";
      });
    });
    modal.open();
  }
  async loadParsedTable(tableName, table, parsed) {
    const columns = [];
    const rows = [];
    const nameToIdMap = /* @__PURE__ */ new Map();
    if ("dice" in table) {
      const diceColId = this.generateColumnId();
      columns.push({
        id: diceColId,
        name: table.dice,
        type: "dice",
        diceNotation: table.dice
      });
      const hasRerollColumn = table.entries.some((e) => e.reroll);
      if (table.entries.length > 0) {
        const firstEntry = table.entries[0];
        if (firstEntry.columns) {
          for (const colName of Object.keys(firstEntry.columns)) {
            const colId = this.generateColumnId();
            nameToIdMap.set(colName, colId);
            if (colName.toLowerCase() === "reroll") {
              columns.push({ id: colId, name: colName, type: "reroll" });
            } else {
              columns.push({ id: colId, name: colName, type: "regular" });
            }
          }
        }
      }
      if (hasRerollColumn && !columns.some((c) => c.type === "reroll")) {
        const rerollColId = this.generateColumnId();
        columns.push({ id: rerollColId, name: "Reroll", type: "reroll" });
        nameToIdMap.set("reroll", rerollColId);
      }
      for (const entry of table.entries) {
        let rangeStr;
        if (entry.max === 999 && entry.min > 1) {
          rangeStr = `${entry.min}+`;
        } else if (entry.min === entry.max) {
          rangeStr = `${entry.min}`;
        } else {
          rangeStr = `${entry.min}-${entry.max}`;
        }
        const row = {
          range: rangeStr
        };
        if (entry.columns) {
          for (const [key, value] of Object.entries(entry.columns)) {
            const newKey = nameToIdMap.get(key) || key;
            row[newKey] = value;
          }
        }
        if (entry.reroll) {
          const rerollColId = nameToIdMap.get("reroll") || "reroll";
          row[rerollColId] = entry.reroll;
        }
        rows.push(row);
      }
    } else {
      for (const header of table.headers) {
        const colId = this.generateColumnId();
        nameToIdMap.set(header, colId);
        if (header.toLowerCase() === "reroll") {
          columns.push({ id: colId, name: header, type: "reroll" });
        } else {
          columns.push({ id: colId, name: header, type: "regular" });
        }
      }
      for (const row of table.rows) {
        const migratedRow = {};
        for (const [key, value] of Object.entries(row)) {
          const newKey = nameToIdMap.get(key) || key;
          migratedRow[newKey] = value;
        }
        rows.push(migratedRow);
      }
    }
    this.state = {
      tableName,
      columns,
      rows,
      isPrivate: table.private || false,
      tableReroll: table.reroll
    };
    this.history = [];
    this.historyIndex = -1;
    this.hasUnsavedChanges = false;
    this.leftPanel.empty();
    this.buildLeftPanel();
    this.updatePreview();
    new import_obsidian2.Notice(`Loaded table: ${tableName}`);
  }
  async saveToCurrentFile() {
    if (!this.currentFile)
      return;
    try {
      const currentContent = await this.app.vault.read(this.currentFile);
      const markdown = this.generateMarkdown();
      const tableName = this.state.tableName;
      const tableHeading = `# ${tableName}`;
      const lines = currentContent.split("\n");
      let tableStartIndex = -1;
      let tableEndIndex = -1;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const headingMatch = line.match(/^#+\s*(.+)$/);
        if (headingMatch && headingMatch[1].trim() === tableName.trim()) {
          tableStartIndex = i;
          break;
        }
      }
      if (tableStartIndex !== -1) {
        tableEndIndex = tableStartIndex;
        for (let i = tableStartIndex + 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (line.match(/^#+\s+/)) {
            break;
          }
          tableEndIndex = i;
        }
        while (tableEndIndex > tableStartIndex && lines[tableEndIndex].trim() === "") {
          tableEndIndex--;
        }
        const markdownLines = markdown.split("\n");
        const tableContentStart = markdownLines.findIndex((l) => l.match(/^#+\s+/));
        const newTableContent = markdownLines.slice(tableContentStart).join("\n");
        const before = lines.slice(0, tableStartIndex);
        const after = lines.slice(tableEndIndex + 1);
        while (before.length > 0 && before[before.length - 1].trim() === "") {
          before.pop();
        }
        while (after.length > 0 && after[0].trim() === "") {
          after.shift();
        }
        const newContent = [...before, "", newTableContent, "", ...after].join("\n");
        await this.app.vault.modify(this.currentFile, newContent);
        new import_obsidian2.Notice(`Saved to ${this.currentFile.path}`);
      } else {
        const markdownLines = markdown.split("\n");
        const tableContentStart = markdownLines.findIndex((l) => l.startsWith("#"));
        const newTableContent = markdownLines.slice(tableContentStart).join("\n");
        const newContent = currentContent + "\n\n" + newTableContent;
        await this.app.vault.modify(this.currentFile, newContent);
        new import_obsidian2.Notice(`Table added to ${this.currentFile.path}`);
      }
      this.hasUnsavedChanges = false;
      await this.roller.loadTables();
    } catch (error) {
      console.error("Error saving to current file:", error);
      new import_obsidian2.Notice("Failed to save to file");
    }
  }
  async exportAs(format) {
    let content = "";
    let extension = "";
    if (format === "md") {
      content = this.generateMarkdown();
      extension = "md";
    } else if (format === "csv") {
      content = this.generateCSV();
      extension = "csv";
    } else if (format === "json") {
      content = this.generateJSON();
      extension = "json";
    }
    await navigator.clipboard.writeText(content);
    new import_obsidian2.Notice(`${format.toUpperCase()} copied to clipboard`);
  }
  generateCSV() {
    const headers = this.state.columns.map((col) => col.name);
    const lines = [headers.join(",")];
    this.state.rows.forEach((row) => {
      const cells = this.state.columns.map((col) => {
        const key = col.type === "dice" ? "range" : col.name;
        const value = row[key] || "";
        return value.includes(",") || value.includes('"') ? `"${value.replace(/"/g, '""')}"` : value;
      });
      lines.push(cells.join(","));
    });
    return lines.join("\n");
  }
  generateJSON() {
    return JSON.stringify({
      tableName: this.state.tableName,
      isPrivate: this.state.isPrivate,
      tableReroll: this.state.tableReroll,
      columns: this.state.columns,
      rows: this.state.rows
    }, null, 2);
  }
  // Validation
  async validate() {
    const errors = [];
    if (!this.state.tableName.trim()) {
      errors.push("Table name cannot be empty");
    }
    if (this.state.tableReroll) {
      const valid = await this.validateRerollReference(this.state.tableReroll, true);
      if (!valid) {
        errors.push(`Invalid table-level reroll reference: ${this.state.tableReroll}`);
      }
    }
    const rerollCol = this.state.columns.find((c) => c.type === "reroll");
    if (rerollCol) {
      for (const row of this.state.rows) {
        const rerollValue = row[rerollCol.id];
        if (rerollValue && rerollValue !== "\u2014" && rerollValue !== "-") {
          const valid = await this.validateRerollReference(rerollValue, true);
          if (!valid) {
            errors.push(`Invalid reroll reference: ${rerollValue}`);
          }
        }
      }
    }
    const diceCol = this.state.columns.find((c) => c.type === "dice");
    if (diceCol) {
      const ranges = [];
      for (const row of this.state.rows) {
        const range = row.range;
        if (range) {
          const parsed = TableParser["parseRange"](range);
          if (parsed.min === 0 && parsed.max === 0) {
            errors.push(`Invalid range format: ${range}`);
          } else {
            ranges.push({ min: parsed.min, max: parsed.max, raw: range });
          }
        }
      }
      for (let i = 0; i < ranges.length; i++) {
        for (let j = i + 1; j < ranges.length; j++) {
          const r1 = ranges[i];
          const r2 = ranges[j];
          if (r1.min <= r2.max && r2.min <= r1.max) {
            errors.push(`Duplicate or overlapping ranges: ${r1.raw} and ${r2.raw}`);
          }
        }
      }
      if (diceCol.diceNotation && ranges.length > 0) {
        const match = diceCol.diceNotation.match(/(\d*)d(\d+)/i);
        if (match) {
          const numDice = match[1] ? parseInt(match[1]) : 1;
          const sides = parseInt(match[2]);
          if (numDice === 1) {
            const sortedRanges = [...ranges].sort((a, b) => a.min - b.min);
            if (sortedRanges[0].min !== 1) {
              errors.push(`Dice ranges should start at 1 (found: ${sortedRanges[0].min})`);
            }
            const lastRange = sortedRanges[sortedRanges.length - 1];
            if (lastRange.max < sides) {
              errors.push(`Dice ranges should cover up to ${sides} for ${diceCol.diceNotation} (highest range ends at: ${lastRange.max})`);
            }
            const hasOverlaps = ranges.some(
              (r1, i) => ranges.some((r2, j) => i !== j && r1.min <= r2.max && r2.min <= r1.max)
            );
            if (!hasOverlaps) {
              for (let i = 0; i < sortedRanges.length - 1; i++) {
                const current = sortedRanges[i];
                const next = sortedRanges[i + 1];
                if (current.max + 1 !== next.min) {
                  errors.push(`Gap in dice ranges between ${current.raw} and ${next.raw}`);
                }
              }
            }
          }
        }
      }
    }
    if (errors.length > 0) {
      const modal = new import_obsidian2.Modal(this.app);
      modal.titleEl.setText("Validation Errors");
      modal.contentEl.createEl("p", { text: "Please fix the following errors:" });
      const list = modal.contentEl.createEl("ul");
      errors.forEach((error) => {
        list.createEl("li", { text: error });
      });
      const closeBtn = modal.contentEl.createEl("button", { text: "OK" });
      closeBtn.addEventListener("click", () => modal.close());
      modal.open();
      return false;
    }
    return true;
  }
  async validateRerollReference(reference, silent = false) {
    const tableNames = reference.split(",").map((t) => t.trim()).filter((t) => t);
    for (const name of tableNames) {
      const multiRollMatch = name.match(/^(\d*d\d+)\s+(.+)$/i);
      const actualTableName = multiRollMatch ? multiRollMatch[2].trim() : name;
      if (actualTableName === this.state.tableName) {
        continue;
      }
      try {
        const tableFile = this.roller.getTableFile(actualTableName);
        if (!tableFile) {
          if (!silent) {
            new import_obsidian2.Notice(`Table not found: ${actualTableName}`);
          }
          return false;
        }
      } catch (error) {
        if (!silent) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          new import_obsidian2.Notice(errorMsg);
        }
        return false;
      }
    }
    return true;
  }
  // Utility
  markUnsaved() {
    this.hasUnsavedChanges = true;
  }
  applyStyles() {
    const styleEl = document.createElement("style");
    styleEl.textContent = `
			.table-builder-view {
				height: 100%;
				overflow: hidden;
			}
			
			.table-builder-split {
				display: flex;
				height: 100%;
				gap: 16px;
				padding: 16px;
			}
			
			.table-builder-left-panel {
				flex: 1;
				overflow-y: auto;
				padding-right: 8px;
			}
			
			.table-builder-right-panel {
				flex: 1;
				display: flex;
				flex-direction: column;
				overflow: hidden;
			}
			
			.table-builder-toolbar {
				display: flex;
				gap: 8px;
				margin-bottom: 16px;
				flex-wrap: wrap;
			}
			
			.table-builder-btn {
				padding: 6px 12px;
				border-radius: 4px;
				border: 1px solid var(--background-modifier-border);
				background: var(--interactive-normal);
				cursor: pointer;
				font-size: 13px;
			}
			
			.table-builder-btn:hover {
				background: var(--interactive-hover);
			}
			
			.table-builder-section {
				margin-bottom: 24px;
			}
			
			.table-builder-section h3 {
				margin: 0 0 12px 0;
				font-size: 14px;
				font-weight: 600;
			}
			
			.table-builder-section label {
				display: block;
				margin-bottom: 6px;
				font-size: 13px;
			}
			
			.table-builder-section input[type="text"] {
				width: 100%;
				padding: 6px 8px;
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				background: var(--background-primary);
			}
			
			.columns-list {
				display: flex;
				flex-direction: column;
				gap: 8px;
				margin-bottom: 12px;
			}
			
			.column-item {
				display: flex;
				align-items: center;
				gap: 8px;
				padding: 8px;
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				background: var(--background-secondary);
			}
			
			.drag-handle {
				cursor: move;
				color: var(--text-muted);
				user-select: none;
			}
			
			.column-item input {
				flex: 1;
				padding: 4px 8px;
				border: 1px solid var(--background-modifier-border);
				border-radius: 3px;
			}
			
			.column-type {
				font-size: 11px;
				color: var(--text-muted);
			}
			
			.delete-btn {
				padding: 2px 8px;
				border: none;
				background: var(--background-modifier-error);
				color: var(--text-on-accent);
				border-radius: 3px;
				cursor: pointer;
				font-size: 16px;
				line-height: 1;
			}
			
			.add-column-btns {
				display: flex;
				gap: 8px;
			}
			
			.directive-item {
				margin-bottom: 12px;
			}
			
			.directive-item label {
				display: flex;
				align-items: center;
				gap: 8px;
			}
			
			.directive-item input[type="checkbox"] {
				margin: 0;
			}
			
			.row-grid-header, .row-grid-row {
				display: grid;
				grid-template-columns: 40px repeat(auto-fit, minmax(100px, 1fr));
				gap: 4px;
				margin-bottom: 4px;
			}
			
			.row-grid-header {
				font-weight: 600;
				border-bottom: 2px solid var(--background-modifier-border);
				padding-bottom: 4px;
			}
			
			.row-number {
				text-align: center;
				padding: 6px;
				color: var(--text-muted);
				cursor: pointer;
			}
			
			.row-grid-row.selected {
				background: var(--background-modifier-hover);
			}
			
			.grid-cell {
				padding: 2px;
			}
			
			.grid-cell input {
				width: 100%;
				padding: 4px 6px;
				border: 1px solid var(--background-modifier-border);
				border-radius: 3px;
				background: var(--background-primary);
			}
			
			.examples-sidebar {
				margin-top: 24px;
				padding-top: 16px;
				border-top: 1px solid var(--background-modifier-border);
			}
			
			.examples-sidebar details {
				cursor: pointer;
			}
			
			.examples-content {
				padding: 12px 0;
			}
			
			.examples-content h4 {
				margin: 8px 0;
				font-size: 13px;
			}
			
			.example-btn {
				display: block;
				width: 100%;
				text-align: left;
				padding: 6px 12px;
				margin-bottom: 4px;
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				background: var(--background-secondary);
				cursor: pointer;
				font-size: 12px;
			}
			
			.example-btn:hover {
				background: var(--background-modifier-hover);
			}
			
			.placeholder-text {
				font-size: 12px;
				color: var(--text-muted);
				font-style: italic;
			}
			
			.preview-tabs {
				display: flex;
				gap: 4px;
				margin-bottom: 12px;
				border-bottom: 1px solid var(--background-modifier-border);
			}
			
			.tab-btn {
				padding: 8px 16px;
				border: none;
				background: transparent;
				cursor: pointer;
				border-bottom: 2px solid transparent;
			}
			
			.tab-btn.active {
				border-bottom-color: var(--interactive-accent);
			}
			
			.preview-container {
				flex: 1;
				overflow-y: auto;
				position: relative;
			}
			
			.markdown-preview, .html-preview {
				display: none;
				padding: 12px;
			}
			
			.markdown-preview.active, .html-preview.active {
				display: block;
			}
			
			.markdown-preview pre {
				background: var(--background-secondary);
				padding: 12px;
				border-radius: 4px;
				overflow-x: auto;
			}
			
			.markdown-preview code {
				font-family: var(--font-monospace);
				font-size: 12px;
				white-space: pre;
			}
			
			.preview-table {
				width: 100%;
				border-collapse: collapse;
			}
			
			.preview-table th, .preview-table td {
				border: 1px solid var(--background-modifier-border);
				padding: 8px;
				text-align: left;
			}
			
			.preview-table th {
				background: var(--background-secondary);
				font-weight: 600;
			}
			
			.directives-info {
				margin-bottom: 12px;
				display: flex;
				gap: 8px;
			}
			
			.badge {
				padding: 4px 8px;
				border-radius: 4px;
				background: var(--background-secondary);
				font-size: 11px;
			}
			
			.export-buttons {
				display: flex;
				gap: 8px;
				flex-wrap: wrap;
				padding: 12px;
				border-top: 1px solid var(--background-modifier-border);
			}
			
			.export-format {
				padding: 6px 12px;
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				background: var(--background-primary);
			}
		`;
    document.head.appendChild(styleEl);
  }
};

// main.ts
var TableRollerPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    console.log("Loading Table Roller plugin");
    this.roller = new TableRollerCore(this.app);
    this.registerView(
      VIEW_TYPE_TABLE_BUILDER,
      (leaf) => new TableBuilderView(leaf, this.roller)
    );
    try {
      await this.roller.loadTables();
    } catch (error) {
      console.error("Error loading tables:", error);
    }
    this.addCommand({
      id: "open-table-builder",
      name: "Create/Edit Table",
      callback: async () => {
        const leaf = this.app.workspace.getLeaf("tab");
        await leaf.setViewState({
          type: VIEW_TYPE_TABLE_BUILDER,
          active: true
        });
      }
    });
    this.addRibbonIcon("table", "Create/Edit Table", async () => {
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.setViewState({
        type: VIEW_TYPE_TABLE_BUILDER,
        active: true
      });
    });
    this.addCommand({
      id: "roll-on-table",
      name: "Roll on table",
      callback: () => {
        const tables = this.roller.getTableNames();
        if (tables.length === 0) {
          console.warn("No tables found with table-roller frontmatter");
          return;
        }
        const selectorModal = new TableSelectorModal(this.app, tables, (tableNameWithModifier) => {
          try {
            let tableName = tableNameWithModifier;
            let modifier = 0;
            if (tableNameWithModifier.includes("@")) {
              const parts = tableNameWithModifier.split("@");
              tableName = parts[0];
              modifier = parseInt(parts[1]) || 0;
            }
            const showRollNumbers = selectorModal.showRollNumbers;
            const performRoll = () => {
              const result = this.roller.roll(tableName, void 0, modifier);
              new RollResultModal(this.app, result, performRoll, showRollNumbers).open();
            };
            performRoll();
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            if (errorMessage.includes("Ambiguous table reference")) {
              new ErrorModal(this.app, "Ambiguous Table Reference", errorMessage).open();
            } else {
              new ErrorModal(this.app, "Error", `Failed to roll on table:

${errorMessage}`).open();
            }
            console.error("Error rolling on table:", error);
          }
        }, this.roller);
        selectorModal.open();
      }
    });
    this.addCommand({
      id: "mark-as-table",
      name: "Mark current file as table",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile || activeFile.extension !== "md") {
          console.warn("No active markdown file");
          return;
        }
        try {
          const content = await this.app.vault.read(activeFile);
          const lines = content.split("\n");
          if (lines[0] === "---") {
            let endIndex = -1;
            for (let i = 1; i < lines.length; i++) {
              if (lines[i] === "---") {
                endIndex = i;
                break;
              }
            }
            if (endIndex > 0) {
              let hasProperty = false;
              for (let i = 1; i < endIndex; i++) {
                if (lines[i].match(/^table-roller\s*:/)) {
                  lines[i] = "table-roller: true";
                  hasProperty = true;
                  break;
                }
              }
              if (!hasProperty) {
                lines.splice(endIndex, 0, "table-roller: true");
              }
            }
          } else {
            lines.unshift("---", "table-roller: true", "---", "");
          }
          await this.app.vault.modify(activeFile, lines.join("\n"));
          console.log("File marked as table-roller");
        } catch (error) {
          console.error("Error marking file as table:", error);
        }
      }
    });
    this.addCommand({
      id: "reload-tables",
      name: "Reload all tables",
      callback: async () => {
        try {
          await this.roller.loadTables();
          console.log("Tables reloaded successfully");
        } catch (error) {
          console.error("Error reloading tables:", error);
        }
      }
    });
  }
  onunload() {
    console.log("Unloading Table Roller plugin");
  }
};
