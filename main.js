/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/plugin/main.js
var main_exports = {};
__export(main_exports, {
  default: () => TableRollerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/services/runtime/RuntimeAdapter.js
var RuntimeAdapter = class {
  constructor(mode = "standalone") {
    this.mode = mode;
    this.fs = null;
    this.path = null;
    this.vault = null;
  }
  /**
   * Initialize the adapter for the current runtime environment
   * @param {Object} options - Configuration options
   * @param {Object} options.vault - Obsidian vault (plugin mode)
   */
  async initialize(options = {}) {
    if (this.mode === "standalone") {
      const fs = await import("fs");
      const path = await import("path");
      this.fs = fs.default || fs;
      this.path = path.default || path;
    } else if (this.mode === "plugin") {
      this.vault = options.vault;
      if (!this.vault) {
        throw new Error("Vault reference required for plugin mode");
      }
    }
  }
  /**
   * Check if a path exists
   * @param {string} filePath - Path to check
   * @returns {Promise<boolean>}
   */
  async exists(filePath) {
    if (this.mode === "standalone") {
      return this.fs.existsSync(filePath);
    } else {
      const file = this.vault.getAbstractFileByPath(filePath);
      return file !== null;
    }
  }
  /**
   * Read file contents
   * @param {string} filePath - Path to file
   * @returns {Promise<string>}
   */
  async readFile(filePath) {
    if (this.mode === "standalone") {
      return this.fs.readFileSync(filePath, "utf-8");
    } else {
      const file = this.vault.getAbstractFileByPath(filePath);
      if (!file) {
        throw new Error(`File not found: ${filePath}`);
      }
      return await this.vault.read(file);
    }
  }
  /**
   * Find all markdown files in a directory
   * @param {string} dir - Directory to search
   * @returns {Promise<string[]>} Array of file paths
   */
  async findMarkdownFiles(dir) {
    if (this.mode === "standalone") {
      return this._findMarkdownFilesNode(dir);
    } else {
      return this._findMarkdownFilesObsidian(dir);
    }
  }
  /**
   * Get basename of a path
   * @param {string} filePath - File path
   * @param {string} ext - Extension to remove (optional)
   * @returns {string}
   */
  basename(filePath, ext) {
    if (this.mode === "standalone") {
      return this.path.basename(filePath, ext);
    } else {
      const parts = filePath.split("/");
      let name = parts[parts.length - 1];
      if (ext && name.endsWith(ext)) {
        name = name.slice(0, -ext.length);
      }
      return name;
    }
  }
  /**
   * Join path segments
   * @param {...string} segments - Path segments
   * @returns {string}
   */
  join(...segments) {
    if (this.mode === "standalone") {
      return this.path.join(...segments);
    } else {
      return segments.join("/").replace(/\/+/g, "/");
    }
  }
  // Private helper methods
  _findMarkdownFilesNode(dir) {
    let results = [];
    const items = this.fs.readdirSync(dir);
    for (const item of items) {
      const fullPath = this.path.join(dir, item);
      const stat = this.fs.statSync(fullPath);
      if (stat.isDirectory()) {
        results = results.concat(this._findMarkdownFilesNode(fullPath));
      } else if (item.endsWith(".md")) {
        results.push(fullPath);
      }
    }
    return results;
  }
  _findMarkdownFilesObsidian(dir) {
    const results = [];
    const files = this.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.startsWith(dir)) {
        results.push(file.path);
      }
    }
    return results;
  }
};

// src/services/tables/TableParser.js
var TableParser = class {
  /**
   * Parse all tables from markdown text
   * @param {string} content - Markdown content
   * @param {string} defaultName - Default name if no heading found
   * @returns {Object} Map of table names to table data
   */
  static parseTables(content, defaultName = "Table") {
    const tables = {};
    const lines = content.split("\n");
    let currentTableName = null;
    let currentTable = [];
    let inTable = false;
    let tableCount = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      const headingMatch = line.match(/^#{1,6}\s+(.+)$/);
      if (headingMatch) {
        currentTableName = headingMatch[1].trim();
        continue;
      }
      if (line.includes("|")) {
        if (!inTable) {
          inTable = true;
          currentTable = [];
          if (!currentTableName) {
            tableCount++;
            currentTableName = tableCount === 1 ? defaultName : `${defaultName}${tableCount}`;
          }
        }
        currentTable.push(line);
      } else if (inTable && currentTable.length > 0) {
        const parsed = this.parseTable(currentTable);
        if (parsed && currentTableName) {
          tables[currentTableName] = parsed;
        }
        inTable = false;
        currentTable = [];
        currentTableName = null;
      }
    }
    if (inTable && currentTable.length > 0) {
      if (!currentTableName) {
        tableCount++;
        currentTableName = tableCount === 1 ? defaultName : `${defaultName}${tableCount}`;
      }
      const parsed = this.parseTable(currentTable);
      if (parsed) {
        tables[currentTableName] = parsed;
      }
    }
    return tables;
  }
  /**
   * Parse a single markdown table
   * @param {string[]} lines - Table lines
   * @returns {Object} Parsed table with headers and rows
   */
  static parseTable(lines) {
    if (lines.length < 2) return null;
    const headers = this.parseRow(lines[0]);
    const rows = [];
    for (let i = 2; i < lines.length; i++) {
      const row = this.parseRow(lines[i]);
      if (row.length > 0) {
        const rowObj = {};
        headers.forEach((header, idx) => {
          rowObj[header] = row[idx] || "";
        });
        rows.push(rowObj);
      }
    }
    return { headers, rows };
  }
  /**
   * Parse a single table row
   * @param {string} line - Table row line
   * @returns {string[]} Cell values
   */
  static parseRow(line) {
    return line.split("|").map((cell) => cell.trim()).filter((cell, idx, arr) => idx !== 0 && idx !== arr.length - 1);
  }
};

// src/services/tables/SessionTracker.js
var SessionTracker = class {
  constructor() {
    this.sessions = /* @__PURE__ */ new Map();
  }
  /**
   * Create a new session
   * @param {string} sessionId - Session identifier
   */
  createSession(sessionId) {
    if (!this.sessions.has(sessionId)) {
      this.sessions.set(sessionId, {
        results: /* @__PURE__ */ new Map(),
        history: []
      });
    }
  }
  /**
   * Record a result for a table in a session
   * @param {string} sessionId - Session identifier
   * @param {string} tableName - Name of the table
   * @param {*} result - The rolled result
   */
  addResult(sessionId, tableName, result) {
    this.createSession(sessionId);
    const session = this.sessions.get(sessionId);
    if (!session.results.has(tableName)) {
      session.results.set(tableName, /* @__PURE__ */ new Set());
    }
    const key = this.getResultKey(result);
    session.results.get(tableName).add(key);
    session.history.push({
      timestamp: /* @__PURE__ */ new Date(),
      tableName,
      result
    });
  }
  /**
   * Check if a result has been rolled before
   * @param {string} sessionId - Session identifier
   * @param {string} tableName - Name of the table
   * @param {*} result - The result to check
   * @returns {boolean} Whether result is a duplicate
   */
  isDuplicate(sessionId, tableName, result) {
    const session = this.sessions.get(sessionId);
    if (!session || !session.results.has(tableName)) {
      return false;
    }
    const key = this.getResultKey(result);
    return session.results.get(tableName).has(key);
  }
  /**
   * Get all results for a table in a session
   * @param {string} sessionId - Session identifier
   * @param {string} tableName - Name of the table
   * @returns {Array} Array of result keys
   */
  getResults(sessionId, tableName) {
    const session = this.sessions.get(sessionId);
    if (!session || !session.results.has(tableName)) {
      return [];
    }
    return Array.from(session.results.get(tableName));
  }
  /**
   * Get session history
   * @param {string} sessionId - Session identifier
   * @returns {Array} History entries
   */
  getHistory(sessionId) {
    const session = this.sessions.get(sessionId);
    return session ? session.history : [];
  }
  /**
   * Clear a session
   * @param {string} sessionId - Session identifier
   */
  clearSession(sessionId) {
    this.sessions.delete(sessionId);
  }
  /**
   * Get a unique key for a result
   * @param {*} result - Result object or value
   * @returns {string} Unique key
   */
  getResultKey(result) {
    if (typeof result === "object" && result !== null) {
      const copy = { ...result };
      delete copy._roll;
      delete copy._chain;
      return JSON.stringify(copy);
    }
    return String(result);
  }
};

// src/services/dice/DiceRoller.js
var DiceRoller = class {
  /**
   * Roll dice using standard notation (e.g., "1d6", "2d10+5", "d20")
   * @param {string} notation - Dice notation
   * @returns {number} Result of the roll
   */
  static roll(notation) {
    const match = notation.match(/^(\d*)d(\d+)([+\-]\d+)?$/i);
    if (!match) {
      throw new Error(`Invalid dice notation: ${notation}`);
    }
    const count = parseInt(match[1] || "1", 10);
    const sides = parseInt(match[2], 10);
    const modifier = parseInt(match[3] || "0", 10);
    let total = 0;
    for (let i = 0; i < count; i++) {
      total += Math.floor(Math.random() * sides) + 1;
    }
    return total + modifier;
  }
  /**
   * Roll on a table using range-based entries
   * @param {Array} rows - Table rows with range column
   * @param {string} rangeColumn - Name of the column with ranges (e.g., "d6", "d100")
   * @param {number} modifier - Modifier to add to the dice roll
   * @returns {Object} Selected row
   */
  static rollOnTable(rows, rangeColumn = "d6", modifier = 0) {
    const baseRoll = this.roll(rangeColumn);
    const rollResult = baseRoll + modifier;
    for (const row of rows) {
      const range = row[rangeColumn];
      if (this.isInRange(rollResult, range)) {
        return {
          ...row,
          _roll: rollResult,
          _baseRoll: baseRoll,
          _modifier: modifier
        };
      }
    }
    const selected = this.randomSelect(rows);
    return {
      ...selected,
      _roll: rollResult,
      _baseRoll: baseRoll,
      _modifier: modifier
    };
  }
  /**
   * Check if a number is in a range string (e.g., "1-3", "4", "5-6", "41+")
   * @param {number} num - Number to check
   * @param {string} range - Range string
   * @returns {boolean} Whether number is in range
   */
  static isInRange(num, range) {
    if (!range) return false;
    const rangeStr = String(range).trim();
    if (/^\d+$/.test(rangeStr)) {
      return num === parseInt(rangeStr, 10);
    }
    const rangeMatch = rangeStr.match(/^(\d+)[-â€“](\d+)$/);
    if (rangeMatch) {
      const min = parseInt(rangeMatch[1], 10);
      const max = parseInt(rangeMatch[2], 10);
      return num >= min && num <= max;
    }
    const openEndedMatch = rangeStr.match(/^(\d+)\+$/);
    if (openEndedMatch) {
      const min = parseInt(openEndedMatch[1], 10);
      return num >= min;
    }
    return false;
  }
  /**
   * Randomly select an item from an array
   * @param {Array} items - Items to select from
   * @returns {*} Random item
   */
  static randomSelect(items) {
    return items[Math.floor(Math.random() * items.length)];
  }
};

// src/services/core/TableRollerCore.js
var TableRollerCore = class {
  constructor(runtime) {
    this.runtime = runtime;
    this.tables = {};
    this.tracker = new SessionTracker();
  }
  /**
   * Load all tables from a directory
   * @param {string} tablesDir - Path to tables directory
   */
  async loadTables(tablesDir = "./tables") {
    const exists = await this.runtime.exists(tablesDir);
    if (!exists) {
      throw new Error(`Tables directory not found: ${tablesDir}`);
    }
    const mdFiles = await this.runtime.findMarkdownFiles(tablesDir);
    for (const filePath of mdFiles) {
      const tableName = this.runtime.basename(filePath, ".md");
      const content = await this.runtime.readFile(filePath);
      const parsed = TableParser.parseTables(content, tableName);
      const tableData = parsed[tableName];
      if (tableData) {
        this.tables[tableName] = tableData;
      }
    }
  }
  /**
   * Roll on a single table with duplicate prevention
   * @param {string} tableName - Table name
   * @param {string} sessionId - Session ID for tracking
   * @param {number} maxAttempts - Maximum reroll attempts
   * @param {number} modifier - Modifier to add to dice roll
   * @returns {Object} Result object
   */
  rollSingle(tableName, sessionId = "default", maxAttempts = 100, modifier = 0) {
    const normalizedName = this._findTableName(tableName);
    if (!normalizedName) {
      throw new Error(`Table not found: ${tableName}`);
    }
    const table = this.tables[normalizedName];
    let attempts = 0;
    let result;
    while (attempts < maxAttempts) {
      const roll = DiceRoller.roll(table.dice) + modifier;
      const entry = table.entries.find((e) => roll >= e.min && roll <= e.max);
      if (!entry) {
        throw new Error(`No entry found for roll ${roll} on table ${normalizedName}`);
      }
      if (!this.tracker.hasBeenRolled(sessionId, normalizedName, entry.result)) {
        result = {
          table: normalizedName,
          dice: table.dice,
          roll,
          modifier,
          rawRoll: roll - modifier,
          result: entry.result,
          details: entry.details,
          attempts: attempts + 1
        };
        this.tracker.recordRoll(sessionId, normalizedName, entry.result);
        break;
      }
      attempts++;
    }
    if (!result) {
      throw new Error(`Failed to get unique result after ${maxAttempts} attempts`);
    }
    return result;
  }
  /**
   * Roll with support for chained tables (e.g., "Table1 -> Table2")
   * @param {string} expression - Roll expression
   * @param {string} sessionId - Session ID
   * @param {number} maxAttempts - Max reroll attempts
   * @param {number} modifier - Modifier for dice rolls
   * @returns {Object} Combined result
   */
  roll(expression, sessionId = "default", maxAttempts = 100, modifier = 0) {
    const tables = expression.split("->").map((t) => t.trim());
    const results = [];
    for (const tableName of tables) {
      const result = this.rollSingle(tableName, sessionId, maxAttempts, modifier);
      results.push(result);
    }
    return {
      expression,
      results,
      sessionId
    };
  }
  /**
   * Format a roll result for display
   * @param {Object} result - Result from roll()
   * @returns {string}
   */
  formatResult(result) {
    let output = [];
    for (const r of result.results) {
      const modStr = r.modifier !== 0 ? ` (${r.rawRoll}${r.modifier >= 0 ? "+" : ""}${r.modifier})` : "";
      output.push(`[${r.table}] ${r.dice}: ${r.roll}${modStr}`);
      output.push(`Result: ${r.result}`);
      if (r.details) {
        output.push(`Details: ${r.details}`);
      }
      if (r.attempts > 1) {
        output.push(`(Required ${r.attempts} attempts for unique result)`);
      }
      output.push("");
    }
    return output.join("\n");
  }
  /**
   * Get list of all loaded table names
   * @returns {string[]}
   */
  getTableNames() {
    return Object.keys(this.tables);
  }
  /**
   * Reset session tracking
   * @param {string} sessionId - Session ID to reset (or 'all')
   */
  resetSession(sessionId = "all") {
    if (sessionId === "all") {
      this.tracker = new SessionTracker();
    } else {
      this.tracker.clearSession(sessionId);
    }
  }
  // Private helper methods
  _findTableName(searchName) {
    const lower = searchName.toLowerCase();
    if (this.tables[searchName]) {
      return searchName;
    }
    for (const name of Object.keys(this.tables)) {
      if (name.toLowerCase() === lower) {
        return name;
      }
    }
    return null;
  }
};

// src/plugin/main.js
var TableRollerPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading Table Roller plugin");
    this.runtime = new RuntimeAdapter("plugin");
    await this.runtime.initialize({ vault: this.app.vault });
    this.roller = new TableRollerCore(this.runtime);
    try {
      await this.roller.loadTables("tables");
      console.log("Loaded tables:", this.roller.getTableNames().join(", "));
    } catch (error) {
      console.error("Error loading tables:", error);
    }
    this.addCommand({
      id: "roll-table",
      name: "Roll on table",
      callback: () => {
        console.log("Roll table command triggered");
      }
    });
  }
  onunload() {
    console.log("Unloading Table Roller plugin");
  }
};
