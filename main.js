/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TableRollerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/services/TableParser.ts
var TableParser = class {
  /**
   * Extract YAML frontmatter from markdown content
   */
  static extractFrontmatter(content) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      return { frontmatter: {}, content };
    }
    const frontmatterText = match[1];
    const bodyContent = match[2];
    const frontmatter = {};
    for (const line of frontmatterText.split("\n")) {
      const keyValue = line.match(/^(\w+(?:-\w+)*)\s*:\s*(.+)$/);
      if (keyValue) {
        const key = keyValue[1].trim();
        let value = keyValue[2].trim();
        if (value === "true")
          value = true;
        else if (value === "false")
          value = false;
        else if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
          value = value.slice(1, -1);
        }
        frontmatter[key] = value;
      }
    }
    return { frontmatter, content: bodyContent };
  }
  /**
   * Parse all tables from markdown content
   */
  static parseTables(content, namespace) {
    const { frontmatter, content: bodyContent } = this.extractFrontmatter(content);
    const isTableFile = frontmatter["table-roller"] === true;
    const tables = {};
    const lines = bodyContent.split("\n");
    let currentTableName = null;
    let currentTableReroll = void 0;
    let currentTable = [];
    let inTable = false;
    let tableCount = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      const headingMatch = line.match(/^#{1,6}\s+(.+)$/);
      if (headingMatch) {
        if (inTable && currentTable.length > 0) {
          const parsed = this.parseTable(currentTable);
          if (parsed && currentTableName) {
            tables[currentTableName] = this.processTable(parsed, currentTableReroll);
          }
          inTable = false;
          currentTable = [];
          currentTableReroll = void 0;
        }
        currentTableName = headingMatch[1].trim();
        continue;
      }
      const rerollMatch = line.match(/^reroll:\s*(.+)$/i);
      if (rerollMatch && currentTableName && !inTable) {
        currentTableReroll = rerollMatch[1].trim();
        continue;
      }
      if (line.includes("|")) {
        if (!inTable) {
          inTable = true;
          currentTable = [];
          if (!currentTableName) {
            tableCount++;
            currentTableName = `${namespace}${tableCount}`;
          }
        }
        currentTable.push(line);
      } else if (inTable && currentTable.length > 0) {
        const parsed = this.parseTable(currentTable);
        if (parsed && currentTableName) {
          tables[currentTableName] = this.processTable(parsed, currentTableReroll);
        }
        inTable = false;
        currentTable = [];
        currentTableName = null;
        currentTableReroll = void 0;
      }
    }
    if (inTable && currentTable.length > 0 && currentTableName) {
      const parsed = this.parseTable(currentTable);
      if (parsed) {
        tables[currentTableName] = this.processTable(parsed, currentTableReroll);
      }
    }
    return { tables, frontmatter, isTableFile, namespace };
  }
  /**
   * Parse a single markdown table into structured data
   */
  static parseTable(lines) {
    if (lines.length < 3)
      return null;
    const headerLine = lines[0];
    const headers = headerLine.split("|").map((h) => h.trim()).filter((h) => h.length > 0);
    if (headers.length === 0)
      return null;
    const rows = [];
    for (let i = 2; i < lines.length; i++) {
      const cells = lines[i].split("|").map((c) => c.trim()).filter((_, idx) => idx > 0 && idx <= headers.length);
      if (cells.length > 0) {
        const row = {};
        headers.forEach((header, idx) => {
          row[header] = cells[idx] || "";
        });
        rows.push(row);
      }
    }
    return { headers, rows };
  }
  /**
   * Process parsed table into dice or simple format
   */
  static processTable(parsed, tableReroll) {
    const diceHeader = parsed.headers.find((h) => /^d\d+$/i.test(h.trim()));
    if (diceHeader) {
      return this.processDiceTable(parsed, diceHeader, tableReroll);
    } else {
      const table = {
        headers: parsed.headers,
        rows: parsed.rows
      };
      if (tableReroll) {
        table.reroll = tableReroll;
      }
      return table;
    }
  }
  /**
   * Process a dice-based table
   */
  static processDiceTable(parsed, diceHeader, tableReroll) {
    const entries = [];
    const rerollHeader = parsed.headers.find((h) => /^reroll$/i.test(h.trim()));
    for (const row of parsed.rows) {
      const range = row[diceHeader];
      const { min, max } = this.parseRange(range);
      let result = "";
      let details = "";
      let reroll;
      for (const [key, value] of Object.entries(row)) {
        if (key === diceHeader || !value || !value.trim())
          continue;
        if (rerollHeader && key === rerollHeader) {
          const trimmed = value.trim();
          if (trimmed !== "\u2014" && trimmed !== "-") {
            reroll = trimmed;
          }
        } else if (!result) {
          result = value;
        } else if (!details) {
          details = value;
        } else {
          details += " | " + value;
        }
      }
      const entry = { min, max, result };
      if (details)
        entry.details = details;
      if (reroll)
        entry.reroll = reroll;
      entries.push(entry);
    }
    const table = {
      dice: diceHeader.toLowerCase(),
      entries
    };
    if (tableReroll) {
      table.reroll = tableReroll;
    }
    return table;
  }
  /**
   * Parse a range string into min/max values
   */
  static parseRange(rangeStr) {
    if (!rangeStr)
      return { min: 0, max: 0 };
    const trimmed = rangeStr.trim();
    if (/^\d+$/.test(trimmed)) {
      const num = parseInt(trimmed);
      return { min: num, max: num };
    }
    const rangeMatch = trimmed.match(/^(\d+)-(\d+)$/);
    if (rangeMatch) {
      return {
        min: parseInt(rangeMatch[1]),
        max: parseInt(rangeMatch[2])
      };
    }
    const openMatch = trimmed.match(/^(\d+)\+$/);
    if (openMatch) {
      return {
        min: parseInt(openMatch[1]),
        max: 999
      };
    }
    return { min: 0, max: 0 };
  }
};

// src/services/DiceRoller.ts
var DiceRoller = class {
  /**
   * Roll dice using standard notation (e.g., "2d6+3", "d20", "1d100-5")
   */
  static roll(notation) {
    const match = notation.match(/(\d*)d(\d+)([+-]\d+)?/i);
    if (!match) {
      throw new Error(`Invalid dice notation: ${notation}`);
    }
    const count = match[1] ? parseInt(match[1]) : 1;
    const sides = parseInt(match[2]);
    const modifier = match[3] ? parseInt(match[3]) : 0;
    let total = 0;
    for (let i = 0; i < count; i++) {
      total += Math.floor(Math.random() * sides) + 1;
    }
    return total + modifier;
  }
  /**
   * Check if a number falls within a range string (e.g., "1-3", "4", "5+")
   */
  static isInRange(value, rangeStr) {
    const trimmed = rangeStr.trim();
    if (/^\d+$/.test(trimmed)) {
      return value === parseInt(trimmed);
    }
    const rangeMatch = trimmed.match(/^(\d+)-(\d+)$/);
    if (rangeMatch) {
      const min = parseInt(rangeMatch[1]);
      const max = parseInt(rangeMatch[2]);
      return value >= min && value <= max;
    }
    const openMatch = trimmed.match(/^(\d+)\+$/);
    if (openMatch) {
      const min = parseInt(openMatch[1]);
      return value >= min;
    }
    return false;
  }
};

// src/services/TableRollerCore.ts
var TableRollerCore = class {
  constructor(app) {
    this.tables = /* @__PURE__ */ new Map();
    this.app = app;
  }
  /**
   * Load all tables from vault files with frontmatter
   */
  async loadTables() {
    this.tables.clear();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      await this.loadTableFromFile(file);
    }
    console.log(`Loaded ${this.tables.size} tables from ${files.length} files`);
  }
  /**
   * Load tables from a single file
   */
  async loadTableFromFile(file) {
    const content = await this.app.vault.read(file);
    const namespace = file.basename;
    const parsed = TableParser.parseTables(content, namespace);
    if (!parsed.isTableFile) {
      return;
    }
    for (const [name, table] of Object.entries(parsed.tables)) {
      this.tables.set(name, { table, namespace });
      const fullName = `${namespace}.${name}`;
      this.tables.set(fullName, { table, namespace });
    }
  }
  /**
   * Get list of all available table names
   */
  getTableNames() {
    const names = /* @__PURE__ */ new Set();
    for (const key of this.tables.keys()) {
      if (!key.includes(".")) {
        names.add(key);
      }
    }
    return Array.from(names).sort();
  }
  /**
   * Roll on a table by name
   */
  roll(tableName, contextNamespace, modifier = 0) {
    const tableData = this.findTable(tableName, contextNamespace);
    if (!tableData) {
      throw new Error(`Table not found: ${tableName}`);
    }
    return this.rollOnTable(tableName, tableData.table, tableData.namespace, modifier);
  }
  /**
   * Roll on a specific table
   */
  rollOnTable(tableName, table, namespace, modifier = 0) {
    let result;
    if (this.isDiceTable(table)) {
      result = this.rollDiceTable(tableName, table, namespace, modifier);
    } else {
      result = this.rollSimpleTable(tableName, table, namespace);
    }
    if (table.reroll) {
      const tableRerolls = this.resolveRerolls(table.reroll, namespace, modifier);
      if (result.nestedRolls) {
        result.nestedRolls.push(...tableRerolls);
      } else {
        result.nestedRolls = tableRerolls;
      }
    }
    return result;
  }
  /**
   * Roll on a dice-based table
   */
  rollDiceTable(tableName, table, namespace, modifier = 0) {
    const baseRoll = DiceRoller.roll(table.dice);
    let rollValue = baseRoll + modifier;
    const minBound = Math.min(...table.entries.map((e) => e.min));
    const maxBound = Math.max(...table.entries.map((e) => e.max));
    rollValue = Math.max(minBound, Math.min(maxBound, rollValue));
    const entry = table.entries.find((e) => rollValue >= e.min && rollValue <= e.max);
    if (!entry) {
      throw new Error(`No entry found for roll ${rollValue} on table ${tableName}`);
    }
    const result = {
      tableName,
      namespace,
      roll: rollValue,
      result: entry.result,
      details: entry.details
    };
    if (entry.reroll) {
      result.nestedRolls = this.resolveRerolls(entry.reroll, namespace, modifier);
    }
    return result;
  }
  /**
   * Roll on a simple table (random row selection)
   */
  rollSimpleTable(tableName, table, namespace) {
    const randomIndex = Math.floor(Math.random() * table.rows.length);
    const row = table.rows[randomIndex];
    const resultParts = [];
    for (const [key, value] of Object.entries(row)) {
      if (value && typeof value === "string" && value.trim()) {
        resultParts.push(`**${key}:** ${value}`);
      }
    }
    return {
      tableName,
      namespace,
      result: resultParts.join("\n")
    };
  }
  /**
   * Resolve reroll references (comma-delimited table names)
   */
  resolveRerolls(rerollString, contextNamespace, modifier = 0) {
    const tableNames = rerollString.split(",").map((t) => t.trim()).filter((t) => t);
    const results = [];
    for (const name of tableNames) {
      const tableData = this.findTable(name, contextNamespace);
      if (tableData) {
        try {
          results.push(this.rollOnTable(name, tableData.table, tableData.namespace, modifier));
        } catch (error) {
          console.warn(`Failed to roll on ${name}:`, error);
        }
      } else {
        console.warn(`Table not found for reroll: ${name}`);
      }
    }
    return results;
  }
  /**
   * Find a table by name with namespace resolution
   * Supports:
   * - Short name (within same namespace)
   * - Full name (Namespace.TableName)
   * - Case-insensitive matching
   */
  findTable(searchName, contextNamespace) {
    let tableData = this.tables.get(searchName);
    if (tableData)
      return tableData;
    if (contextNamespace && !searchName.includes(".")) {
      const namespacedName = `${contextNamespace}.${searchName}`;
      tableData = this.tables.get(namespacedName);
      if (tableData)
        return tableData;
    }
    const lower = searchName.toLowerCase();
    for (const [key, data] of this.tables.entries()) {
      if (key.toLowerCase() === lower) {
        return data;
      }
    }
    return null;
  }
  /**
   * Check if a table is dice-based
   */
  isDiceTable(table) {
    return "dice" in table && "entries" in table;
  }
};

// src/ui/modals.ts
var import_obsidian = require("obsidian");
var TableSelectorModal = class extends import_obsidian.Modal {
  constructor(app, tables, onSelect) {
    super(app);
    this.tables = tables;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select a table to roll on" });
    const checkboxContainer = contentEl.createEl("div");
    checkboxContainer.style.marginTop = "12px";
    checkboxContainer.style.marginBottom = "16px";
    checkboxContainer.style.padding = "12px";
    checkboxContainer.style.backgroundColor = "var(--background-secondary)";
    checkboxContainer.style.borderRadius = "6px";
    const checkboxLabel = checkboxContainer.createEl("label");
    checkboxLabel.style.display = "flex";
    checkboxLabel.style.alignItems = "center";
    checkboxLabel.style.cursor = "pointer";
    const checkbox = checkboxLabel.createEl("input", { type: "checkbox" });
    checkbox.style.marginRight = "8px";
    const labelText = checkboxLabel.createEl("span", { text: "Roll with modifiers" });
    labelText.style.fontWeight = "500";
    let useModifiers = false;
    checkbox.addEventListener("change", () => {
      useModifiers = checkbox.checked;
    });
    const listEl = contentEl.createEl("div", { cls: "table-list" });
    listEl.style.display = "flex";
    listEl.style.flexDirection = "column";
    listEl.style.gap = "8px";
    listEl.style.marginTop = "16px";
    for (const tableName of this.tables) {
      const buttonEl = listEl.createEl("button", {
        text: tableName,
        cls: "table-button"
      });
      buttonEl.style.padding = "12px 16px";
      buttonEl.style.cursor = "pointer";
      buttonEl.style.borderRadius = "6px";
      buttonEl.style.border = "1px solid var(--background-modifier-border)";
      buttonEl.style.backgroundColor = "var(--interactive-normal)";
      buttonEl.style.color = "var(--text-normal)";
      buttonEl.style.textAlign = "left";
      buttonEl.style.fontSize = "14px";
      buttonEl.style.fontWeight = "500";
      buttonEl.style.transition = "all 0.15s ease";
      buttonEl.addEventListener("click", () => {
        if (useModifiers) {
          new ModifierPreviewModal(this.app, tableName, this.onSelect).open();
        } else {
          this.onSelect(tableName);
        }
        this.close();
      });
      buttonEl.addEventListener("mouseenter", () => {
        buttonEl.style.backgroundColor = "var(--interactive-hover)";
        buttonEl.style.borderColor = "var(--interactive-accent)";
        buttonEl.style.transform = "translateX(4px)";
      });
      buttonEl.addEventListener("mouseleave", () => {
        buttonEl.style.backgroundColor = "var(--interactive-normal)";
        buttonEl.style.borderColor = "var(--background-modifier-border)";
        buttonEl.style.transform = "translateX(0)";
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var RollResultModal = class extends import_obsidian.Modal {
  constructor(app, result, onReroll) {
    super(app);
    this.result = result;
    this.onReroll = onReroll;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.displayResult(contentEl, this.result, 2);
    const buttonDiv = contentEl.createEl("div", { cls: "modal-button-container" });
    buttonDiv.style.marginTop = "20px";
    buttonDiv.style.display = "flex";
    buttonDiv.style.justifyContent = "space-between";
    buttonDiv.style.gap = "8px";
    const leftDiv = buttonDiv.createEl("div");
    if (this.onReroll) {
      const rerollButton = leftDiv.createEl("button", { text: "Reroll" });
      rerollButton.addEventListener("click", () => {
        var _a;
        this.close();
        (_a = this.onReroll) == null ? void 0 : _a.call(this);
      });
    }
    const rightDiv = buttonDiv.createEl("div");
    rightDiv.style.display = "flex";
    rightDiv.style.gap = "8px";
    const copyButton = rightDiv.createEl("button", { text: "Copy to Clipboard" });
    copyButton.addEventListener("click", async () => {
      const markdown = this.formatResultAsMarkdown(this.result);
      await navigator.clipboard.writeText(markdown);
      copyButton.textContent = "Copied!";
      setTimeout(() => {
        copyButton.textContent = "Copy to Clipboard";
      }, 2e3);
    });
    const saveButton = rightDiv.createEl("button", { text: "Save to Obsidian" });
    saveButton.addEventListener("click", () => {
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -5);
      const defaultFilename = `${this.result.tableName}-${timestamp}`;
      const markdown = this.formatResultAsMarkdown(this.result);
      new SaveFileModal(this.app, defaultFilename, markdown).open();
    });
    const closeButton = rightDiv.createEl("button", { text: "Close" });
    closeButton.addEventListener("click", () => this.close());
  }
  /**
   * Format result as markdown string
   */
  formatResultAsMarkdown(result, level = 2) {
    const lines = [];
    const heading = "#".repeat(level);
    lines.push(`${heading} ${result.tableName}`);
    if (result.namespace) {
      lines.push(`*[${result.namespace}]*`);
    }
    lines.push("");
    if (result.roll !== void 0) {
      lines.push(`**Roll:** ${result.roll}`);
    }
    lines.push(`**Result:** ${result.result}`);
    if (result.details) {
      lines.push(`**Details:** ${result.details}`);
    }
    if (result.nestedRolls && result.nestedRolls.length > 0) {
      lines.push("");
      lines.push("**Referenced Tables:**");
      lines.push("");
      for (const nested of result.nestedRolls) {
        lines.push(this.formatResultAsMarkdown(nested, Math.min(level + 1, 6)));
      }
    }
    return lines.join("\n");
  }
  displayResult(container, result, headingLevel) {
    const heading = container.createEl(`h${headingLevel}`, { text: result.tableName });
    if (result.namespace) {
      const namespaceBadge = heading.createEl("span", {
        text: ` [${result.namespace}]`,
        cls: "namespace-badge"
      });
      namespaceBadge.style.fontSize = "0.8em";
      namespaceBadge.style.opacity = "0.7";
      namespaceBadge.style.fontWeight = "normal";
    }
    if (result.roll !== void 0) {
      const rollEl = container.createEl("p", { cls: "roll-value" });
      rollEl.innerHTML = `<strong>Roll:</strong> ${result.roll}`;
      rollEl.style.marginBottom = "8px";
    }
    const resultEl = container.createEl("div", { cls: "result-text" });
    resultEl.innerHTML = `<strong>Result:</strong> ${result.result}`;
    resultEl.style.marginBottom = "8px";
    if (result.details) {
      const detailsEl = container.createEl("div", { cls: "result-details" });
      detailsEl.innerHTML = `<strong>Details:</strong> ${result.details}`;
      detailsEl.style.marginBottom = "12px";
    }
    if (result.nestedRolls && result.nestedRolls.length > 0) {
      const nestedHeader = container.createEl("p", {
        text: "Referenced Tables:",
        cls: "nested-header"
      });
      nestedHeader.style.fontWeight = "bold";
      nestedHeader.style.marginTop = "12px";
      nestedHeader.style.marginBottom = "8px";
      for (const nested of result.nestedRolls) {
        const nestedDiv = container.createEl("div", { cls: "nested-roll" });
        nestedDiv.style.marginLeft = "20px";
        nestedDiv.style.paddingLeft = "12px";
        nestedDiv.style.borderLeft = "3px solid var(--background-modifier-border)";
        nestedDiv.style.marginTop = "12px";
        this.displayResult(nestedDiv, nested, Math.min(headingLevel + 1, 6));
      }
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ModifierPreviewModal = class extends import_obsidian.Modal {
  constructor(app, tableName, onRoll) {
    super(app);
    this.tableName = tableName;
    this.onRoll = onRoll;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Configure Roll Modifiers" });
    const infoText = contentEl.createEl("p", {
      text: "Add modifiers to dice rolls. Note: Modifiers only apply to dice-based tables (d6, d20, etc.)."
    });
    infoText.style.fontSize = "13px";
    infoText.style.opacity = "0.8";
    infoText.style.marginBottom = "16px";
    const mainTableDiv = contentEl.createEl("div");
    mainTableDiv.style.marginBottom = "20px";
    const mainLabel = mainTableDiv.createEl("div");
    mainLabel.style.fontWeight = "600";
    mainLabel.style.marginBottom = "8px";
    mainLabel.style.fontSize = "15px";
    mainLabel.createEl("span", { text: `${this.tableName}` });
    const mainBadge = mainLabel.createEl("span", { text: " [Main Table]" });
    mainBadge.style.fontSize = "12px";
    mainBadge.style.opacity = "0.7";
    mainBadge.style.fontWeight = "normal";
    const mainInputContainer = mainTableDiv.createEl("div");
    mainInputContainer.style.display = "flex";
    mainInputContainer.style.alignItems = "center";
    mainInputContainer.style.gap = "8px";
    const mainInput = mainInputContainer.createEl("input", {
      type: "number",
      placeholder: "0"
    });
    mainInput.style.width = "100px";
    mainInput.style.padding = "8px 12px";
    mainInput.style.borderRadius = "4px";
    mainInput.style.border = "1px solid var(--background-modifier-border)";
    mainInput.style.fontSize = "14px";
    mainInput.value = "0";
    mainInputContainer.createEl("span", {
      text: "Modifier (e.g., +2 or -3)"
    }).style.opacity = "0.7";
    const noteDiv = contentEl.createEl("div");
    noteDiv.style.marginTop = "16px";
    noteDiv.style.padding = "12px";
    noteDiv.style.backgroundColor = "var(--background-secondary)";
    noteDiv.style.borderRadius = "6px";
    noteDiv.style.fontSize = "13px";
    const noteIcon = noteDiv.createEl("span", { text: "\u{1F4A1} " });
    noteDiv.createEl("span", {
      text: "Additional tables from rerolls will use this same modifier. Future updates may allow per-table modifiers for nested rolls."
    });
    const buttonDiv = contentEl.createEl("div");
    buttonDiv.style.marginTop = "24px";
    buttonDiv.style.display = "flex";
    buttonDiv.style.justifyContent = "flex-end";
    buttonDiv.style.gap = "8px";
    const rollButton = buttonDiv.createEl("button", { text: "Roll" });
    rollButton.style.fontWeight = "600";
    rollButton.addEventListener("click", () => {
      const modifier = parseInt(mainInput.value) || 0;
      const tableWithModifier = modifier !== 0 ? `${this.tableName}@${modifier}` : this.tableName;
      this.onRoll(tableWithModifier);
      this.close();
    });
    const cancelButton = buttonDiv.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    mainInput.focus();
    mainInput.select();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SaveFileModal = class extends import_obsidian.Modal {
  constructor(app, defaultFilename, content) {
    super(app);
    this.defaultFilename = defaultFilename;
    this.content = content;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Save to file" });
    const inputContainer = contentEl.createEl("div");
    inputContainer.style.marginTop = "16px";
    inputContainer.style.marginBottom = "16px";
    const label = inputContainer.createEl("label", { text: "Filename:" });
    label.style.display = "block";
    label.style.marginBottom = "8px";
    label.style.fontWeight = "500";
    const input = inputContainer.createEl("input", {
      type: "text",
      value: this.defaultFilename
    });
    input.style.width = "100%";
    input.style.padding = "8px 12px";
    input.style.borderRadius = "4px";
    input.style.border = "1px solid var(--background-modifier-border)";
    input.style.fontSize = "14px";
    const extension = inputContainer.createEl("span", { text: ".md" });
    extension.style.marginLeft = "4px";
    extension.style.opacity = "0.7";
    const buttonDiv = contentEl.createEl("div");
    buttonDiv.style.marginTop = "20px";
    buttonDiv.style.display = "flex";
    buttonDiv.style.justifyContent = "flex-end";
    buttonDiv.style.gap = "8px";
    const saveButton = buttonDiv.createEl("button", { text: "Save" });
    saveButton.addEventListener("click", async () => {
      const filename = input.value.trim() || this.defaultFilename;
      await this.saveFile(filename);
      this.close();
    });
    const cancelButton = buttonDiv.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    input.focus();
    input.select();
    input.addEventListener("keypress", async (e) => {
      if (e.key === "Enter") {
        const filename = input.value.trim() || this.defaultFilename;
        await this.saveFile(filename);
        this.close();
      }
    });
  }
  async saveFile(filename) {
    const fullFilename = filename.endsWith(".md") ? filename : `${filename}.md`;
    try {
      await this.app.vault.create(fullFilename, this.content);
      console.log(`Saved roll result to ${fullFilename}`);
    } catch (error) {
      console.error("Error saving file:", error);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var TableRollerPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    console.log("Loading Table Roller plugin");
    this.roller = new TableRollerCore(this.app);
    try {
      await this.roller.loadTables();
    } catch (error) {
      console.error("Error loading tables:", error);
    }
    this.addCommand({
      id: "roll-on-table",
      name: "Roll on table",
      callback: () => {
        const tables = this.roller.getTableNames();
        if (tables.length === 0) {
          console.warn("No tables found with table-roller frontmatter");
          return;
        }
        new TableSelectorModal(this.app, tables, (tableNameWithModifier) => {
          try {
            let tableName = tableNameWithModifier;
            let modifier = 0;
            if (tableNameWithModifier.includes("@")) {
              const parts = tableNameWithModifier.split("@");
              tableName = parts[0];
              modifier = parseInt(parts[1]) || 0;
            }
            const performRoll = () => {
              const result = this.roller.roll(tableName, void 0, modifier);
              new RollResultModal(this.app, result, performRoll).open();
            };
            performRoll();
          } catch (error) {
            console.error("Error rolling on table:", error);
          }
        }).open();
      }
    });
    this.addCommand({
      id: "reload-tables",
      name: "Reload all tables",
      callback: async () => {
        try {
          await this.roller.loadTables();
          console.log("Tables reloaded successfully");
        } catch (error) {
          console.error("Error reloading tables:", error);
        }
      }
    });
  }
  onunload() {
    console.log("Unloading Table Roller plugin");
  }
};
