/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TableRollerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/services/TableParser.ts
var TableParser = class {
  /**
   * Extract YAML frontmatter from markdown content
   */
  static extractFrontmatter(content) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      return { frontmatter: {}, content };
    }
    const frontmatterText = match[1];
    const bodyContent = match[2];
    const frontmatter = {};
    for (const line of frontmatterText.split("\n")) {
      const keyValue = line.match(/^(\w+(?:-\w+)*)\s*:\s*(.+)$/);
      if (keyValue) {
        const key = keyValue[1].trim();
        let value = keyValue[2].trim();
        if (value === "true")
          value = true;
        else if (value === "false")
          value = false;
        else if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
          value = value.slice(1, -1);
        }
        frontmatter[key] = value;
      }
    }
    return { frontmatter, content: bodyContent };
  }
  /**
   * Parse all tables from markdown content
   */
  static parseTables(content, namespace) {
    const { frontmatter, content: bodyContent } = this.extractFrontmatter(content);
    const isTableFile = frontmatter["table-roller"] === true;
    const tables = {};
    const lines = bodyContent.split("\n");
    let currentTableName = null;
    let currentTableReroll = void 0;
    let currentTablePrivate = false;
    let currentTable = [];
    let inTable = false;
    let tableCount = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      const headingMatch = line.match(/^#{1,6}\s+(.+)$/);
      if (headingMatch) {
        if (inTable && currentTable.length > 0) {
          const parsed = this.parseTable(currentTable);
          if (parsed && currentTableName) {
            tables[currentTableName] = this.processTable(parsed, currentTableReroll, currentTablePrivate);
          }
          inTable = false;
          currentTable = [];
          currentTableReroll = void 0;
          currentTablePrivate = false;
        }
        currentTableName = headingMatch[1].trim();
        console.log(`Found heading: "${currentTableName}"`);
        continue;
      }
      const rerollMatch = line.match(/^reroll:\s*(.+)$/i);
      if (rerollMatch && currentTableName && !inTable) {
        currentTableReroll = rerollMatch[1].trim();
        continue;
      }
      const privateMatch = line.match(/^private:\s*(true|yes|1)$/i);
      if (privateMatch && currentTableName && !inTable) {
        currentTablePrivate = true;
        continue;
      }
      if (line.includes("|")) {
        if (!inTable) {
          inTable = true;
          currentTable = [];
          if (!currentTableName) {
            tableCount++;
            currentTableName = `${namespace}${tableCount}`;
          }
        }
        currentTable.push(line);
      } else if (inTable && currentTable.length > 0) {
        const parsed = this.parseTable(currentTable);
        if (parsed && currentTableName) {
          tables[currentTableName] = this.processTable(parsed, currentTableReroll, currentTablePrivate);
        }
        inTable = false;
        currentTable = [];
        currentTableName = null;
        currentTableReroll = void 0;
        currentTablePrivate = false;
        currentTablePrivate = false;
      }
    }
    if (inTable && currentTable.length > 0 && currentTableName) {
      const parsed = this.parseTable(currentTable);
      if (parsed) {
        tables[currentTableName] = this.processTable(parsed, currentTableReroll, currentTablePrivate);
      }
    }
    return { tables, frontmatter, isTableFile, namespace };
  }
  /**
   * Parse a single markdown table into structured data
   */
  static parseTable(lines) {
    if (lines.length < 3)
      return null;
    const headerLine = lines[0];
    const headers = headerLine.split("|").map((h) => h.trim()).filter((h) => h.length > 0);
    if (headers.length === 0)
      return null;
    const rows = [];
    for (let i = 2; i < lines.length; i++) {
      const cells = lines[i].split("|").map((c) => c.trim()).filter((_, idx) => idx > 0 && idx <= headers.length);
      if (cells.length > 0) {
        const row = {};
        headers.forEach((header, idx) => {
          row[header] = cells[idx] || "";
        });
        rows.push(row);
      }
    }
    return { headers, rows };
  }
  /**
   * Process parsed table into dice or simple format
   */
  static processTable(parsed, tableReroll, tablePrivate) {
    const diceHeader = parsed.headers.find((h) => /^\d*d\d+$/i.test(h.trim()));
    if (diceHeader) {
      return this.processDiceTable(parsed, diceHeader, tableReroll, tablePrivate);
    } else {
      const table = {
        headers: parsed.headers,
        rows: parsed.rows
      };
      if (tableReroll) {
        table.reroll = tableReroll;
      }
      if (tablePrivate) {
        table.private = tablePrivate;
      }
      return table;
    }
  }
  /**
   * Process a dice-based table
   */
  static processDiceTable(parsed, diceHeader, tableReroll, tablePrivate) {
    const entries = [];
    const rerollHeader = parsed.headers.find((h) => /^reroll$/i.test(h.trim()));
    for (const row of parsed.rows) {
      const range = row[diceHeader];
      const { min, max } = this.parseRange(range);
      let result = "";
      let details = "";
      let reroll;
      const columns = {};
      for (const [key, value] of Object.entries(row)) {
        if (key === diceHeader)
          continue;
        const isRerollColumn = rerollHeader && key.toLowerCase().trim() === rerollHeader.toLowerCase().trim();
        if (isRerollColumn) {
          const trimmed = value.trim();
          if (trimmed && trimmed !== "\u2014" && trimmed !== "-") {
            reroll = trimmed;
          }
          continue;
        }
        if (!value || !value.trim())
          continue;
        columns[key] = value;
        if (!result) {
          result = value;
        } else if (!details) {
          details = value;
        } else {
          details += " | " + value;
        }
      }
      const entry = { min, max, result, columns };
      if (details)
        entry.details = details;
      if (reroll)
        entry.reroll = reroll;
      entries.push(entry);
    }
    const table = {
      dice: diceHeader.toLowerCase(),
      entries
    };
    if (tableReroll) {
      table.reroll = tableReroll;
    }
    if (tablePrivate) {
      table.private = tablePrivate;
    }
    return table;
  }
  /**
   * Parse a range string into min/max values
   */
  static parseRange(rangeStr) {
    if (!rangeStr)
      return { min: 0, max: 0 };
    const trimmed = rangeStr.trim();
    if (/^\d+$/.test(trimmed)) {
      const num = parseInt(trimmed);
      return { min: num, max: num };
    }
    const rangeMatch = trimmed.match(/^(\d+)[\-\u2013\u2014](\d+)$/);
    if (rangeMatch) {
      return {
        min: parseInt(rangeMatch[1]),
        max: parseInt(rangeMatch[2])
      };
    }
    const openMatch = trimmed.match(/^(\d+)\+$/);
    if (openMatch) {
      return {
        min: parseInt(openMatch[1]),
        max: 999
      };
    }
    return { min: 0, max: 0 };
  }
};

// src/services/DiceRoller.ts
var DiceRoller = class {
  /**
   * Roll dice using standard notation (e.g., "2d6+3", "d20", "1d100-5")
   */
  static roll(notation) {
    const match = notation.match(/(\d*)d(\d+)([+-]\d+)?/i);
    if (!match) {
      throw new Error(`Invalid dice notation: ${notation}`);
    }
    const count = match[1] ? parseInt(match[1]) : 1;
    const sides = parseInt(match[2]);
    const modifier = match[3] ? parseInt(match[3]) : 0;
    let total = 0;
    for (let i = 0; i < count; i++) {
      total += Math.floor(Math.random() * sides) + 1;
    }
    return total + modifier;
  }
  /**
   * Check if a number falls within a range string (e.g., "1-3", "4", "5+")
   */
  static isInRange(value, rangeStr) {
    const trimmed = rangeStr.trim();
    if (/^\d+$/.test(trimmed)) {
      return value === parseInt(trimmed);
    }
    const rangeMatch = trimmed.match(/^(\d+)-(\d+)$/);
    if (rangeMatch) {
      const min = parseInt(rangeMatch[1]);
      const max = parseInt(rangeMatch[2]);
      return value >= min && value <= max;
    }
    const openMatch = trimmed.match(/^(\d+)\+$/);
    if (openMatch) {
      const min = parseInt(openMatch[1]);
      return value >= min;
    }
    return false;
  }
};

// src/services/TableRollerCore.ts
var TableRollerCore = class {
  constructor(app) {
    this.tables = /* @__PURE__ */ new Map();
    this.app = app;
  }
  /**
   * Load all tables from vault files with frontmatter
   */
  async loadTables() {
    this.tables.clear();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      await this.loadTableFromFile(file);
    }
    console.log(`Loaded ${this.tables.size} tables from ${files.length} files`);
  }
  /**
   * Load tables from a single file
   */
  async loadTableFromFile(file) {
    const content = await this.app.vault.read(file);
    const namespace = file.basename;
    const parsed = TableParser.parseTables(content, namespace);
    if (!parsed.isTableFile) {
      return;
    }
    for (const [name, table] of Object.entries(parsed.tables)) {
      const fullName = `${namespace}.${name}`;
      this.tables.set(fullName, { table, namespace, file });
    }
  }
  /**
   * Get source file path for a table
   */
  getTableFile(tableName, contextNamespace) {
    const tableData = this.findTable(tableName, contextNamespace);
    return tableData == null ? void 0 : tableData.file;
  }
  /**
   * Get list of all available table names
   */
  getTableNames() {
    const names = /* @__PURE__ */ new Set();
    for (const [key, data] of this.tables.entries()) {
      if (!data.table.private) {
        const parts = key.split(".");
        if (parts.length === 2) {
          names.add(parts[1]);
        }
      }
    }
    return Array.from(names).sort();
  }
  /**
   * Roll on a table by name
   */
  roll(tableName, contextNamespace, modifier = 0) {
    const tableData = this.findTable(tableName, contextNamespace);
    if (!tableData) {
      throw new Error(`Table not found: ${tableName}`);
    }
    return this.rollOnTable(tableName, tableData.table, tableData.namespace, tableData.file.path, modifier);
  }
  /**
   * Roll on a specific table
   */
  rollOnTable(tableName, table, namespace, sourceFile, modifier = 0) {
    let result;
    if (this.isDiceTable(table)) {
      result = this.rollDiceTable(tableName, table, namespace, sourceFile, modifier);
    } else {
      result = this.rollSimpleTable(tableName, table, namespace, sourceFile);
    }
    if (table.reroll) {
      const tableRerolls = this.resolveRerolls(table.reroll, namespace, 0);
      if (result.nestedRolls) {
        result.nestedRolls.push(...tableRerolls);
      } else {
        result.nestedRolls = tableRerolls;
      }
    }
    return result;
  }
  /**
   * Roll on a dice-based table
   */
  rollDiceTable(tableName, table, namespace, sourceFile, modifier = 0) {
    const baseRoll = DiceRoller.roll(table.dice);
    let rollValue = baseRoll + modifier;
    const minBound = Math.min(...table.entries.map((e) => e.min));
    const maxBound = Math.max(...table.entries.map((e) => e.max));
    rollValue = Math.max(minBound, Math.min(maxBound, rollValue));
    const entry = table.entries.find((e) => rollValue >= e.min && rollValue <= e.max);
    if (!entry) {
      throw new Error(`No entry found for roll ${rollValue} on table ${tableName}`);
    }
    const result = {
      tableName,
      namespace,
      roll: rollValue,
      result: entry.result,
      details: entry.details,
      columns: entry.columns,
      sourceFile
    };
    if (entry.reroll) {
      result.nestedRolls = this.resolveRerolls(entry.reroll, namespace, 0);
    }
    return result;
  }
  /**
   * Roll on a simple table (random row selection)
   */
  rollSimpleTable(tableName, table, namespace, sourceFile) {
    const randomIndex = Math.floor(Math.random() * table.rows.length);
    const row = table.rows[randomIndex];
    const resultParts = [];
    for (const [key, value] of Object.entries(row)) {
      if (value && typeof value === "string" && value.trim()) {
        resultParts.push(`**${key}:** ${value}`);
      }
    }
    return {
      tableName,
      namespace,
      result: resultParts.join("\n"),
      sourceFile
    };
  }
  /**
   * Resolve reroll references (comma-delimited table names)
   * Supports multi-roll syntax: d6 TableName, 1d6 TableName, 2d8 TableName, etc.
   */
  resolveRerolls(rerollString, contextNamespace, modifier = 0) {
    const tableNames = rerollString.split(",").map((t) => t.trim()).filter((t) => t);
    const results = [];
    for (const name of tableNames) {
      const multiRollMatch = name.match(/^(\d*d\d+)\s+(.+)$/i);
      let rollCount = 1;
      let actualTableName = name;
      if (multiRollMatch) {
        try {
          rollCount = DiceRoller.roll(multiRollMatch[1]);
          actualTableName = multiRollMatch[2].trim();
        } catch (error) {
          console.warn(`Invalid dice notation in reroll: ${multiRollMatch[1]}`, error);
          continue;
        }
      }
      const tableData = this.findTable(actualTableName, contextNamespace);
      if (tableData) {
        try {
          for (let i = 0; i < rollCount; i++) {
            results.push(this.rollOnTable(actualTableName, tableData.table, tableData.namespace, tableData.file.path, modifier));
          }
        } catch (error) {
          console.warn(`Failed to roll on ${actualTableName}:`, error);
        }
      } else {
        console.warn(`Table not found for reroll: ${actualTableName}`);
      }
    }
    return results;
  }
  /**
   * Find a table by name with namespace resolution
   * Supports:
   * - Short name (within same namespace)
   * - Full name (Namespace.TableName)
   * - Case-insensitive matching
   * Throws error if ambiguous matches found across files
   */
  findTable(searchName, contextNamespace) {
    if (searchName.includes(".")) {
      const tableData = this.tables.get(searchName);
      if (tableData)
        return tableData;
      const lower2 = searchName.toLowerCase();
      for (const [key, data] of this.tables.entries()) {
        if (key.toLowerCase() === lower2) {
          return data;
        }
      }
      return null;
    }
    if (contextNamespace) {
      const namespacedName = `${contextNamespace}.${searchName}`;
      const localTable = this.tables.get(namespacedName);
      if (localTable) {
        return localTable;
      }
    }
    const matches = [];
    const lower = searchName.toLowerCase();
    for (const [key, data] of this.tables.entries()) {
      const parts = key.split(".");
      if (parts.length !== 2)
        continue;
      const tableName = parts[1];
      if (tableName.toLowerCase() === lower) {
        matches.push({ key, data });
      }
    }
    if (matches.length === 0) {
      return null;
    }
    if (matches.length === 1) {
      return matches[0].data;
    }
    const fileList = matches.map((m) => m.data.namespace).join(", ");
    throw new Error(
      `Ambiguous table reference: "${searchName}" exists in multiple files (${fileList}). Use the format "FileName.${searchName}" to specify which table to use.`
    );
  }
  /**
   * Check if a table is dice-based
   */
  isDiceTable(table) {
    return "dice" in table && "entries" in table;
  }
};

// src/ui/modals.ts
var import_obsidian = require("obsidian");
var TableSelectorModal = class extends import_obsidian.Modal {
  constructor(app, tables, onSelect, roller) {
    super(app);
    this.showRollNumbers = false;
    this.tables = tables;
    this.onSelect = onSelect;
    this.roller = roller;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select a table to roll on" });
    const checkboxContainer = contentEl.createEl("div", { cls: "modal-checkbox-container" });
    const checkboxLabel = checkboxContainer.createEl("label", { cls: "modal-checkbox-label" });
    const checkbox = checkboxLabel.createEl("input", { type: "checkbox", cls: "modal-checkbox" });
    const labelText = checkboxLabel.createEl("span", {
      text: "Roll with modifiers",
      cls: "modal-checkbox-text"
    });
    let useModifiers = false;
    checkbox.addEventListener("change", () => {
      useModifiers = checkbox.checked;
    });
    const rollNumsContainer = contentEl.createEl("div", { cls: "modal-checkbox-container" });
    const rollNumsLabel = rollNumsContainer.createEl("label", { cls: "modal-checkbox-label" });
    const rollNumsCheckbox = rollNumsLabel.createEl("input", { type: "checkbox", cls: "modal-checkbox" });
    const rollNumsLabelText = rollNumsLabel.createEl("span", {
      text: "Show roll numbers",
      cls: "modal-checkbox-text"
    });
    rollNumsCheckbox.addEventListener("change", () => {
      this.showRollNumbers = rollNumsCheckbox.checked;
    });
    const listEl = contentEl.createEl("div", { cls: "modal-table-list" });
    for (const tableName of this.tables) {
      const buttonEl = listEl.createEl("button", {
        text: tableName,
        cls: "modal-table-button"
      });
      buttonEl.addEventListener("click", () => {
        if (useModifiers) {
          new ModifierPreviewModal(this.app, tableName, this.onSelect).open();
        } else {
          this.onSelect(tableName);
        }
        this.close();
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var RollResultModal = class extends import_obsidian.Modal {
  constructor(app, result, onReroll, showRollNumbers = false) {
    super(app);
    this.result = result;
    this.onReroll = onReroll;
    this.showRollNumbers = showRollNumbers;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.displayResult(contentEl, this.result, 2, this.showRollNumbers);
    const buttonDiv = contentEl.createEl("div", { cls: "modal-button-container" });
    const leftDiv = buttonDiv.createEl("div", { cls: "modal-button-group" });
    if (this.onReroll) {
      const rerollButton = leftDiv.createEl("button", { text: "Reroll" });
      rerollButton.addEventListener("click", () => {
        var _a;
        this.close();
        (_a = this.onReroll) == null ? void 0 : _a.call(this);
      });
    }
    const rightDiv = buttonDiv.createEl("div", { cls: "modal-button-group" });
    const copyButton = rightDiv.createEl("button", { text: "Copy to Clipboard" });
    copyButton.addEventListener("click", async () => {
      const markdown = this.formatResultAsMarkdown(this.result);
      await navigator.clipboard.writeText(markdown);
      copyButton.textContent = "Copied!";
      setTimeout(() => {
        copyButton.textContent = "Copy to Clipboard";
      }, 2e3);
    });
    const saveButton = rightDiv.createEl("button", { text: "Save to Obsidian" });
    saveButton.addEventListener("click", () => {
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -5);
      const defaultFilename = `${this.result.tableName}-${timestamp}`;
      const markdown = this.formatResultAsMarkdown(this.result);
      new SaveFileModal(this.app, defaultFilename, markdown).open();
    });
    const closeButton = rightDiv.createEl("button", { text: "Close" });
    closeButton.addEventListener("click", () => this.close());
  }
  /**
   * Format result as markdown string
   */
  formatResultAsMarkdown(result, level = 2) {
    const lines = [];
    const heading = "#".repeat(level);
    lines.push(`${heading} ${result.tableName}`);
    if (result.namespace) {
      lines.push(`*[[${result.namespace}]]*`);
    }
    lines.push("");
    if (result.columns && Object.keys(result.columns).length > 0) {
      for (const [header, value] of Object.entries(result.columns)) {
        if (value && value.trim()) {
          lines.push(`**${header}:** ${value}`);
        }
      }
    } else {
      lines.push(`**Result:** ${result.result}`);
      if (result.details) {
        lines.push(`**Details:** ${result.details}`);
      }
    }
    if (this.showRollNumbers && result.roll !== void 0) {
      lines.push(`**Roll:** ${result.roll}`);
    }
    if (result.nestedRolls && result.nestedRolls.length > 0) {
      lines.push("");
      lines.push("**Referenced Tables:**");
      lines.push("");
      for (const nested of result.nestedRolls) {
        lines.push(this.formatResultAsMarkdown(nested, Math.min(level + 1, 6)));
      }
    }
    return lines.join("\n");
  }
  displayResult(container, result, headingLevel, showRollNumbers = false) {
    const heading = container.createEl(`h${headingLevel}`, { text: result.tableName });
    if (result.namespace) {
      const namespaceBadge = heading.createEl("span", {
        cls: "modal-namespace-badge"
      });
      if (result.sourceFile) {
        const link = namespaceBadge.createEl("a", {
          text: ` [${result.namespace}]`,
          href: "#",
          cls: "modal-namespace-link"
        });
        link.addEventListener("click", async (e) => {
          e.preventDefault();
          const file = this.app.vault.getAbstractFileByPath(result.sourceFile);
          if (file && file instanceof import_obsidian.TFile) {
            await this.app.workspace.getLeaf().openFile(file);
            this.close();
          }
        });
      } else {
        namespaceBadge.textContent = ` [${result.namespace}]`;
      }
    }
    if (result.columns && Object.keys(result.columns).length > 0) {
      for (const [header, value] of Object.entries(result.columns)) {
        if (value && value.trim()) {
          const colEl = container.createEl("div", { cls: "modal-result-column" });
          colEl.innerHTML = `<strong>${header}:</strong> ${value}`;
        }
      }
    } else {
      const resultEl = container.createEl("div", { cls: "modal-result-text" });
      resultEl.innerHTML = `<strong>Result:</strong> ${result.result}`;
      if (result.details) {
        const detailsEl = container.createEl("div", { cls: "modal-result-details" });
        detailsEl.innerHTML = `<strong>Details:</strong> ${result.details}`;
      }
    }
    if (showRollNumbers && result.roll !== void 0) {
      const rollEl = container.createEl("p", { cls: "modal-roll-value" });
      rollEl.innerHTML = `<strong>Roll:</strong> ${result.roll}`;
    }
    if (result.nestedRolls && result.nestedRolls.length > 0) {
      const nestedHeader = container.createEl("p", {
        text: "Referenced Tables:",
        cls: "modal-nested-header"
      });
      for (const nested of result.nestedRolls) {
        const nestedDiv = container.createEl("div", { cls: "modal-nested-roll" });
        this.displayResult(nestedDiv, nested, Math.min(headingLevel + 1, 6), showRollNumbers);
      }
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ModifierPreviewModal = class extends import_obsidian.Modal {
  constructor(app, tableName, onRoll) {
    super(app);
    this.tableName = tableName;
    this.onRoll = onRoll;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Configure Roll Modifiers" });
    const infoText = contentEl.createEl("p", {
      text: "Add modifiers to dice rolls. Note: Modifiers only apply to dice-based tables (d6, d20, etc.).",
      cls: "modal-info-text"
    });
    const mainTableDiv = contentEl.createEl("div", { cls: "modal-modifier-section" });
    const mainLabel = mainTableDiv.createEl("div", { cls: "modal-modifier-label" });
    mainLabel.createEl("span", { text: `${this.tableName}` });
    const mainBadge = mainLabel.createEl("span", {
      text: " [Main Table]",
      cls: "modal-modifier-badge"
    });
    const mainInputContainer = mainTableDiv.createEl("div", { cls: "modal-input-container" });
    const mainInput = mainInputContainer.createEl("input", {
      type: "number",
      placeholder: "0",
      cls: "modal-modifier-input"
    });
    mainInput.value = "0";
    const inputHint = mainInputContainer.createEl("span", {
      text: "Modifier (e.g., +2 or -3)",
      cls: "modal-input-hint"
    });
    const noteDiv = contentEl.createEl("div", { cls: "modal-note" });
    const noteIcon = noteDiv.createEl("span", { text: "\u{1F4A1} " });
    noteDiv.createEl("span", {
      text: "Additional tables from rerolls will use this same modifier. Future updates may allow per-table modifiers for nested rolls."
    });
    const buttonDiv = contentEl.createEl("div", { cls: "modal-button-container" });
    const rollButton = buttonDiv.createEl("button", {
      text: "Roll",
      cls: "modal-button-primary"
    });
    rollButton.addEventListener("click", () => {
      const modifier = parseInt(mainInput.value) || 0;
      const tableWithModifier = modifier !== 0 ? `${this.tableName}@${modifier}` : this.tableName;
      this.onRoll(tableWithModifier);
      this.close();
    });
    const cancelButton = buttonDiv.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    mainInput.focus();
    mainInput.select();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SaveFileModal = class extends import_obsidian.Modal {
  constructor(app, defaultFilename, content) {
    super(app);
    this.defaultFilename = defaultFilename;
    this.content = content;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Save to file" });
    const inputContainer = contentEl.createEl("div", { cls: "modal-input-section" });
    const label = inputContainer.createEl("label", {
      text: "Filename:",
      cls: "modal-label"
    });
    const input = inputContainer.createEl("input", {
      type: "text",
      value: this.defaultFilename,
      cls: "modal-filename-input"
    });
    const extension = inputContainer.createEl("span", {
      text: ".md",
      cls: "modal-extension"
    });
    const buttonDiv = contentEl.createEl("div", { cls: "modal-button-container" });
    const saveButton = buttonDiv.createEl("button", { text: "Save" });
    saveButton.addEventListener("click", async () => {
      const filename = input.value.trim() || this.defaultFilename;
      await this.saveFile(filename);
      this.close();
    });
    const cancelButton = buttonDiv.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    input.focus();
    input.select();
    input.addEventListener("keypress", async (e) => {
      if (e.key === "Enter") {
        const filename = input.value.trim() || this.defaultFilename;
        await this.saveFile(filename);
        this.close();
      }
    });
  }
  async saveFile(filename) {
    const fullFilename = filename.endsWith(".md") ? filename : `${filename}.md`;
    try {
      await this.app.vault.create(fullFilename, this.content);
      console.log(`Saved roll result to ${fullFilename}`);
    } catch (error) {
      console.error("Error saving file:", error);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ErrorModal = class extends import_obsidian.Modal {
  constructor(app, title, message) {
    super(app);
    this.title = title;
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: this.title });
    const messageContainer = contentEl.createDiv({ cls: "modal-error-message" });
    messageContainer.setText(this.message);
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container modal-button-centered" });
    const closeButton = buttonContainer.createEl("button", {
      text: "OK",
      cls: "modal-button-ok"
    });
    closeButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/TableBuilderView.ts
var import_obsidian5 = require("obsidian");

// src/ui/utils/TableBuilderUtils.ts
function generateDefaultRows(diceNotation, count, groupSize, remainder) {
  const rows = [];
  const match = diceNotation.match(/^(\d*)d(\d+)$/i);
  if (!match)
    return rows;
  const numDice = match[1] ? parseInt(match[1]) : 1;
  const sides = parseInt(match[2]);
  const minValue = numDice;
  const maxValue = numDice * sides;
  const totalRange = maxValue - minValue + 1;
  if (groupSize && groupSize >= 2) {
    const extraValues = totalRange % groupSize;
    let currentValue = minValue;
    const remainderStrategy = remainder || "expand-last";
    if (remainderStrategy === "row-first" && extraValues > 0) {
      const end = minValue + extraValues - 1;
      if (minValue === end) {
        rows.push({ range: `${minValue}` });
      } else {
        rows.push({ range: `${minValue}-${end}` });
      }
      currentValue = end + 1;
    }
    const mainRowCount = Math.floor(totalRange / groupSize);
    for (let i = 0; i < mainRowCount; i++) {
      let rangeSize = groupSize;
      if (extraValues > 0) {
        if (remainderStrategy === "expand-first" && i === 0) {
          rangeSize = groupSize + extraValues;
        } else if (remainderStrategy === "expand-last" && i === mainRowCount - 1) {
          rangeSize = groupSize + extraValues;
        }
      }
      const start = currentValue;
      const end = Math.min(currentValue + rangeSize - 1, maxValue);
      if (start === end) {
        rows.push({ range: `${start}` });
      } else {
        rows.push({ range: `${start}-${end}` });
      }
      currentValue = end + 1;
    }
    if (remainderStrategy === "row-last" && extraValues > 0 && currentValue <= maxValue) {
      if (currentValue === maxValue) {
        rows.push({ range: `${maxValue}` });
      } else {
        rows.push({ range: `${currentValue}-${maxValue}` });
      }
    }
  } else if (count < totalRange) {
    const calculatedGroupSize = Math.floor(totalRange / count);
    const extraValues = totalRange % count;
    let currentValue = minValue;
    for (let i = 0; i < count; i++) {
      let rangeSize = calculatedGroupSize;
      if (i === count - 1 && extraValues > 0) {
        rangeSize = calculatedGroupSize + extraValues;
      }
      const start = currentValue;
      const end = Math.min(currentValue + rangeSize - 1, maxValue);
      if (start === end) {
        rows.push({ range: `${start}` });
      } else {
        rows.push({ range: `${start}-${end}` });
      }
      currentValue = end + 1;
    }
  } else {
    for (let i = minValue; i <= Math.min(maxValue, minValue + count - 1); i++) {
      rows.push({ range: `${i}` });
    }
  }
  return rows;
}
function generateMarkdown(state) {
  const lines = [];
  lines.push("---");
  lines.push("table-roller: true");
  lines.push("---");
  lines.push("");
  lines.push(`# ${state.tableName}`);
  lines.push("");
  if (state.isPrivate) {
    lines.push("private: true");
  }
  if (state.tableReroll) {
    lines.push(`reroll: ${state.tableReroll}`);
  }
  if (state.isPrivate || state.tableReroll) {
    lines.push("");
  }
  const headers = state.columns.map((col) => col.name);
  lines.push("| " + headers.join(" | ") + " |");
  lines.push("|" + headers.map(() => "----").join("|") + "|");
  state.rows.forEach((row) => {
    const cells = state.columns.map((col) => {
      const key = col.type === "dice" ? "range" : col.name;
      return row[key] || "";
    });
    lines.push("| " + cells.join(" | ") + " |");
  });
  return lines.join("\n");
}
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// src/ui/state/TableBuilderState.ts
var StateManager = class extends EventTarget {
  /**
   * Creates a new StateManager with the given initial state
   * @param initialState - The initial table state
   */
  constructor(initialState) {
    super();
    this.history = [];
    this.historyIndex = -1;
    this.MAX_HISTORY = 50;
    this.currentState = deepClone(initialState);
    this.captureState();
  }
  /**
   * Captures the current state to the history stack
   * Removes any forward history if we're not at the end
   * Maintains history size limit
   */
  captureState() {
    if (this.historyIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.historyIndex + 1);
    }
    const stateCopy = deepClone(this.currentState);
    this.history.push({
      state: stateCopy,
      timestamp: Date.now()
    });
    if (this.history.length > this.MAX_HISTORY) {
      this.history.shift();
    } else {
      this.historyIndex++;
    }
  }
  /**
   * Undoes the last state change
   * Returns true if undo was successful, false if at beginning of history
   */
  undo() {
    if (!this.canUndo()) {
      return false;
    }
    this.historyIndex--;
    this.currentState = deepClone(this.history[this.historyIndex].state);
    this.dispatchStateChange();
    return true;
  }
  /**
   * Redoes the previously undone state change
   * Returns true if redo was successful, false if at end of history
   */
  redo() {
    if (!this.canRedo()) {
      return false;
    }
    this.historyIndex++;
    this.currentState = deepClone(this.history[this.historyIndex].state);
    this.dispatchStateChange();
    return true;
  }
  /**
   * Gets the current state
   * Returns a deep clone to prevent external mutations
   */
  getState() {
    return deepClone(this.currentState);
  }
  /**
   * Sets a new state and captures it to history
   * @param newState - The new state to set
   * @param captureHistory - Whether to capture this change in history (default: true)
   */
  setState(newState, captureHistory = true) {
    this.currentState = deepClone(newState);
    if (captureHistory) {
      this.captureState();
    }
    this.dispatchStateChange();
  }
  /**
   * Checks if undo operation is available
   * @returns True if there are states to undo to
   */
  canUndo() {
    return this.historyIndex > 0;
  }
  /**
   * Checks if redo operation is available
   * @returns True if there are states to redo to
   */
  canRedo() {
    return this.historyIndex < this.history.length - 1;
  }
  /**
   * Gets the number of available undo operations
   */
  getUndoCount() {
    return this.historyIndex;
  }
  /**
   * Gets the number of available redo operations
   */
  getRedoCount() {
    return this.history.length - 1 - this.historyIndex;
  }
  /**
   * Clears all history and resets to the current state
   */
  clearHistory() {
    this.history = [];
    this.historyIndex = -1;
    this.captureState();
  }
  /**
   * Dispatches a custom event notifying listeners of state changes
   * Event name: 'state-changed'
   * Event detail: Current table state
   */
  dispatchStateChange() {
    const event = new CustomEvent("state-changed", {
      detail: deepClone(this.currentState)
    });
    this.dispatchEvent(event);
  }
  /**
   * Updates the current state without capturing to history
   * Useful for temporary state changes or during initialization
   * @param newState - The new state to set
   */
  updateStateWithoutHistory(newState) {
    this.currentState = deepClone(newState);
    this.dispatchStateChange();
  }
  /**
   * Gets the current history index
   * Useful for debugging or displaying history position
   */
  getHistoryIndex() {
    return this.historyIndex;
  }
  /**
   * Gets the total history length
   * Useful for debugging or displaying history information
   */
  getHistoryLength() {
    return this.history.length;
  }
};

// src/ui/io/TableBuilderIO.ts
var import_obsidian2 = require("obsidian");
var TableIO = class extends EventTarget {
  constructor(app, currentFile, parser) {
    super();
    this.app = app;
    this.currentFile = currentFile;
    this.parser = parser;
    this.state = this.getDefaultState();
  }
  /**
   * Get the default table state
   */
  getDefaultState() {
    return {
      tableName: "New Table",
      columns: [
        { name: "d6", type: "dice", diceNotation: "d6" },
        { name: "Result", type: "regular" }
      ],
      rows: [],
      isPrivate: false
    };
  }
  /**
   * Set the current state (called from view)
   */
  setState(state) {
    this.state = state;
  }
  /**
   * Get the current file
   */
  getCurrentFile() {
    return this.currentFile;
  }
  /**
   * Set the current file
   */
  setCurrentFile(file) {
    this.currentFile = file;
  }
  /**
   * Generate markdown content from state
   */
  generateMarkdown(state) {
    const lines = [];
    lines.push("---");
    lines.push("table-roller: true");
    lines.push("---");
    lines.push("");
    lines.push(`# ${state.tableName}`);
    lines.push("");
    if (state.isPrivate) {
      lines.push("private: true");
    }
    if (state.tableReroll) {
      lines.push(`reroll: ${state.tableReroll}`);
    }
    if (state.isPrivate || state.tableReroll) {
      lines.push("");
    }
    const headers = state.columns.map((col) => col.name);
    lines.push("| " + headers.join(" | ") + " |");
    lines.push("|" + headers.map(() => "----").join("|") + "|");
    state.rows.forEach((row) => {
      const cells = state.columns.map((col) => {
        const key = col.type === "dice" ? "range" : col.name;
        return row[key] || "";
      });
      lines.push("| " + cells.join(" | ") + " |");
    });
    return lines.join("\n");
  }
  /**
   * Generate CSV content from state
   */
  generateCSV(state) {
    const headers = state.columns.map((col) => col.name);
    const lines = [headers.join(",")];
    state.rows.forEach((row) => {
      const cells = state.columns.map((col) => {
        const key = col.type === "dice" ? "range" : col.name;
        const value = row[key] || "";
        return value.includes(",") || value.includes('"') ? `"${value.replace(/"/g, '""')}"` : value;
      });
      lines.push(cells.join(","));
    });
    return lines.join("\n");
  }
  /**
   * Generate JSON content from state
   */
  generateJSON(state) {
    return JSON.stringify({
      tableName: state.tableName,
      isPrivate: state.isPrivate,
      tableReroll: state.tableReroll,
      columns: state.columns,
      rows: state.rows
    }, null, 2);
  }
  /**
   * Save table to current file or prompt for new file
   */
  async save() {
    try {
      if (this.currentFile) {
        await this.saveToCurrentFile();
      } else {
        await this.saveAs();
      }
    } catch (error) {
      console.error("Error in save:", error);
      new import_obsidian2.Notice("Failed to save table");
    }
  }
  /**
   * Show save as dialog (new file or append)
   */
  async saveAs() {
    return new Promise((resolve) => {
      const modal = new import_obsidian2.Modal(this.app);
      modal.titleEl.setText("Save Table As");
      const createNewBtn = modal.contentEl.createEl("button", {
        text: "Create New File",
        cls: "table-builder-btn"
      });
      createNewBtn.style.width = "100%";
      createNewBtn.style.marginBottom = "8px";
      createNewBtn.addEventListener("click", async () => {
        modal.close();
        await this.saveToNewFile();
        resolve();
      });
      const appendBtn = modal.contentEl.createEl("button", {
        text: "Append to Existing File",
        cls: "table-builder-btn"
      });
      appendBtn.style.width = "100%";
      appendBtn.addEventListener("click", async () => {
        modal.close();
        await this.appendToFile();
        resolve();
      });
      modal.onClose = () => resolve();
      modal.open();
    });
  }
  /**
   * Save to a new file with user-specified filename
   */
  async saveToNewFile() {
    return new Promise((resolve) => {
      const modal = new import_obsidian2.Modal(this.app);
      modal.titleEl.setText("Save to New File");
      const input = modal.contentEl.createEl("input", {
        type: "text",
        placeholder: "Filename (without .md)",
        value: this.state.tableName
      });
      input.style.width = "100%";
      input.style.padding = "8px";
      input.style.marginBottom = "12px";
      const btnContainer = modal.contentEl.createDiv();
      btnContainer.style.display = "flex";
      btnContainer.style.justifyContent = "flex-end";
      btnContainer.style.gap = "8px";
      const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve();
      });
      const saveBtn = btnContainer.createEl("button", { text: "Save" });
      saveBtn.addEventListener("click", async () => {
        const filename = input.value.trim();
        if (!filename) {
          new import_obsidian2.Notice("Filename cannot be empty");
          return;
        }
        const fullFilename = filename.endsWith(".md") ? filename : `${filename}.md`;
        const markdown = this.generateMarkdown(this.state);
        try {
          const file = await this.app.vault.create(fullFilename, markdown);
          new import_obsidian2.Notice(`Saved to ${fullFilename}`);
          this.currentFile = file;
          this.dispatchEvent(new CustomEvent("file-saved", {
            detail: { file, tableName: this.state.tableName }
          }));
          modal.close();
          resolve();
        } catch (error) {
          console.error("Error saving file:", error);
          new import_obsidian2.Notice("Failed to save file");
        }
      });
      input.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          saveBtn.click();
        }
      });
      modal.onClose = () => resolve();
      modal.open();
      input.focus();
    });
  }
  /**
   * Save to the current file (update existing table)
   */
  async saveToCurrentFile() {
    if (!this.currentFile) {
      new import_obsidian2.Notice("No current file to save to");
      return;
    }
    try {
      const currentContent = await this.app.vault.read(this.currentFile);
      const markdown = this.generateMarkdown(this.state);
      const tableName = this.state.tableName;
      const lines = currentContent.split("\n");
      let tableStartIndex = -1;
      let tableEndIndex = -1;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const headingMatch = line.match(/^#+\s*(.+)$/);
        if (headingMatch && headingMatch[1].trim() === tableName.trim()) {
          tableStartIndex = i;
          break;
        }
      }
      if (tableStartIndex !== -1) {
        tableEndIndex = tableStartIndex;
        for (let i = tableStartIndex + 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (line.match(/^#+\s+/)) {
            break;
          }
          tableEndIndex = i;
        }
        while (tableEndIndex > tableStartIndex && lines[tableEndIndex].trim() === "") {
          tableEndIndex--;
        }
        const markdownLines = markdown.split("\n");
        const tableContentStart = markdownLines.findIndex((l) => l.match(/^#+\s+/));
        const newTableContent = markdownLines.slice(tableContentStart).join("\n");
        const before = lines.slice(0, tableStartIndex);
        const after = lines.slice(tableEndIndex + 1);
        while (before.length > 0 && before[before.length - 1].trim() === "") {
          before.pop();
        }
        while (after.length > 0 && after[0].trim() === "") {
          after.shift();
        }
        const newContent = [...before, "", newTableContent, "", ...after].join("\n");
        await this.app.vault.modify(this.currentFile, newContent);
        new import_obsidian2.Notice(`Saved to ${this.currentFile.path}`);
      } else {
        const markdownLines = markdown.split("\n");
        const tableContentStart = markdownLines.findIndex((l) => l.startsWith("#"));
        const newTableContent = markdownLines.slice(tableContentStart).join("\n");
        const newContent = currentContent + "\n\n" + newTableContent;
        await this.app.vault.modify(this.currentFile, newContent);
        new import_obsidian2.Notice(`Table added to ${this.currentFile.path}`);
      }
      this.dispatchEvent(new CustomEvent("file-saved", {
        detail: { file: this.currentFile, tableName: this.state.tableName }
      }));
    } catch (error) {
      console.error("Error saving to current file:", error);
      new import_obsidian2.Notice("Failed to save to file");
    }
  }
  /**
   * Show file picker and append table to selected file
   */
  async appendToFile() {
    const files = this.app.vault.getMarkdownFiles().filter((f) => !f.path.startsWith(".table-templates/"));
    if (files.length === 0) {
      new import_obsidian2.Notice("No markdown files found");
      return;
    }
    return new Promise((resolve) => {
      const modal = new import_obsidian2.Modal(this.app);
      modal.titleEl.setText("Select File to Append To");
      const fileList = modal.contentEl.createDiv({ cls: "file-list" });
      fileList.style.maxHeight = "400px";
      fileList.style.overflowY = "auto";
      files.forEach((file) => {
        const fileBtn = fileList.createEl("button", {
          text: file.path,
          cls: "file-option"
        });
        fileBtn.style.display = "block";
        fileBtn.style.width = "100%";
        fileBtn.style.textAlign = "left";
        fileBtn.style.padding = "8px";
        fileBtn.style.marginBottom = "4px";
        fileBtn.style.border = "1px solid var(--background-modifier-border)";
        fileBtn.style.background = "var(--background-secondary)";
        fileBtn.style.cursor = "pointer";
        fileBtn.addEventListener("click", async () => {
          modal.close();
          await this.appendToSpecificFile(file);
          resolve();
        });
        fileBtn.addEventListener("mouseenter", () => {
          fileBtn.style.background = "var(--background-modifier-hover)";
        });
        fileBtn.addEventListener("mouseleave", () => {
          fileBtn.style.background = "var(--background-secondary)";
        });
      });
      modal.onClose = () => resolve();
      modal.open();
    });
  }
  /**
   * Append table to a specific file
   */
  async appendToSpecificFile(file) {
    try {
      const currentContent = await this.app.vault.read(file);
      const markdown = this.generateMarkdown(this.state);
      const lines = markdown.split("\n");
      const tableStartIndex = lines.findIndex((l) => l.startsWith("#"));
      const tableContent = lines.slice(tableStartIndex).join("\n");
      const newContent = currentContent + "\n\n" + tableContent;
      await this.app.vault.modify(file, newContent);
      new import_obsidian2.Notice(`Appended to ${file.path}`);
      this.currentFile = file;
      this.dispatchEvent(new CustomEvent("file-appended", {
        detail: { file, tableName: this.state.tableName }
      }));
    } catch (error) {
      console.error("Error appending to file:", error);
      new import_obsidian2.Notice("Failed to append to file");
    }
  }
  /**
   * Load table from file with file picker
   */
  async load() {
    const files = this.app.vault.getMarkdownFiles().filter((f) => !f.path.startsWith(".table-templates/"));
    if (files.length === 0) {
      new import_obsidian2.Notice("No markdown files found");
      return;
    }
    return new Promise((resolve) => {
      const modal = new import_obsidian2.Modal(this.app);
      modal.titleEl.setText("Load Table from File");
      const fileList = modal.contentEl.createDiv({ cls: "file-list" });
      fileList.style.maxHeight = "400px";
      fileList.style.overflowY = "auto";
      files.forEach((file) => {
        const fileBtn = fileList.createEl("button", {
          text: file.path,
          cls: "file-option"
        });
        fileBtn.style.display = "block";
        fileBtn.style.width = "100%";
        fileBtn.style.textAlign = "left";
        fileBtn.style.padding = "8px";
        fileBtn.style.marginBottom = "4px";
        fileBtn.style.border = "1px solid var(--background-modifier-border)";
        fileBtn.style.background = "var(--background-secondary)";
        fileBtn.style.cursor = "pointer";
        fileBtn.addEventListener("click", async () => {
          modal.close();
          await this.loadFromFile(file);
          resolve();
        });
        fileBtn.addEventListener("mouseenter", () => {
          fileBtn.style.background = "var(--background-modifier-hover)";
        });
        fileBtn.addEventListener("mouseleave", () => {
          fileBtn.style.background = "var(--background-secondary)";
        });
      });
      modal.onClose = () => resolve();
      modal.open();
    });
  }
  /**
   * Load table from a specific file
   */
  async loadFromFile(file) {
    try {
      this.currentFile = file;
      const content = await this.app.vault.read(file);
      const parsed = TableParser.parseTables(content, file.basename);
      const tableNames = Object.keys(parsed.tables);
      if (tableNames.length === 0) {
        new import_obsidian2.Notice("No tables found in file");
        return;
      }
      if (tableNames.length === 1) {
        await this.loadParsedTable(tableNames[0], parsed.tables[tableNames[0]], parsed);
      } else {
        await this.showTablePicker(tableNames, parsed);
      }
    } catch (error) {
      console.error("Error loading table:", error);
      new import_obsidian2.Notice("Failed to load table");
    }
  }
  /**
   * Show table picker modal when multiple tables exist in file
   */
  async showTablePicker(tableNames, parsed) {
    return new Promise((resolve) => {
      const modal = new import_obsidian2.Modal(this.app);
      modal.titleEl.setText("Select Table");
      const tableList = modal.contentEl.createDiv({ cls: "table-list" });
      tableNames.forEach((name) => {
        const btn = tableList.createEl("button", {
          text: name,
          cls: "table-option"
        });
        btn.style.display = "block";
        btn.style.width = "100%";
        btn.style.textAlign = "left";
        btn.style.padding = "8px";
        btn.style.marginBottom = "4px";
        btn.style.border = "1px solid var(--background-modifier-border)";
        btn.style.background = "var(--background-secondary)";
        btn.style.cursor = "pointer";
        btn.addEventListener("click", async () => {
          modal.close();
          await this.loadParsedTable(name, parsed.tables[name], parsed);
          resolve();
        });
        btn.addEventListener("mouseenter", () => {
          btn.style.background = "var(--background-modifier-hover)";
        });
        btn.addEventListener("mouseleave", () => {
          btn.style.background = "var(--background-secondary)";
        });
      });
      modal.onClose = () => resolve();
      modal.open();
    });
  }
  /**
   * Load a parsed table into state
   */
  async loadParsedTable(tableName, table, parsed) {
    const columns = [];
    const rows = [];
    if ("dice" in table) {
      columns.push({
        name: table.dice,
        type: "dice",
        diceNotation: table.dice
      });
      if (table.entries.length > 0) {
        const firstEntry = table.entries[0];
        if (firstEntry.columns) {
          for (const colName of Object.keys(firstEntry.columns)) {
            if (colName.toLowerCase() === "reroll") {
              columns.push({ name: colName, type: "reroll" });
            } else {
              columns.push({ name: colName, type: "regular" });
            }
          }
        }
      }
      for (const entry of table.entries) {
        const row = {
          range: entry.min === entry.max ? `${entry.min}` : `${entry.min}-${entry.max}`
        };
        if (entry.columns) {
          for (const [key, value] of Object.entries(entry.columns)) {
            row[key] = value;
          }
        }
        if (entry.reroll) {
          row.reroll = entry.reroll;
        }
        rows.push(row);
      }
    } else {
      for (const header of table.headers) {
        if (header.toLowerCase() === "reroll") {
          columns.push({ name: header, type: "reroll" });
        } else {
          columns.push({ name: header, type: "regular" });
        }
      }
      for (const row of table.rows) {
        rows.push({ ...row });
      }
    }
    this.state = {
      tableName,
      columns,
      rows,
      isPrivate: table.private || false,
      tableReroll: table.reroll
    };
    this.dispatchEvent(new CustomEvent("file-loaded", {
      detail: {
        file: this.currentFile,
        tableName,
        state: this.state
      }
    }));
    new import_obsidian2.Notice(`Loaded table: ${tableName}`);
  }
  /**
   * Export table in specified format
   */
  async exportAs(format) {
    try {
      let content = "";
      switch (format) {
        case "md":
          content = this.generateMarkdown(this.state);
          break;
        case "csv":
          content = this.generateCSV(this.state);
          break;
        case "json":
          content = this.generateJSON(this.state);
          break;
      }
      await navigator.clipboard.writeText(content);
      new import_obsidian2.Notice(`${format.toUpperCase()} copied to clipboard`);
      this.dispatchEvent(new CustomEvent("export-completed", {
        detail: { format, content }
      }));
    } catch (error) {
      console.error("Error exporting:", error);
      new import_obsidian2.Notice("Failed to export table");
    }
  }
  /**
   * Save current table as a template
   */
  async saveTemplate(templateName) {
    try {
      const templatesFolder = ".table-templates";
      const folder = this.app.vault.getAbstractFileByPath(templatesFolder);
      if (!folder) {
        await this.app.vault.createFolder(templatesFolder);
      }
      const templateState = {
        tableName: templateName,
        columns: JSON.parse(JSON.stringify(this.state.columns)),
        rows: this.state.rows.map(() => ({})),
        // Empty rows with same count
        isPrivate: this.state.isPrivate,
        tableReroll: this.state.tableReroll
      };
      const lines = [];
      lines.push("---");
      lines.push("table-roller-template: true");
      lines.push("---");
      lines.push("");
      lines.push(`# ${templateName}`);
      lines.push("");
      lines.push("```json");
      lines.push(JSON.stringify(templateState, null, 2));
      lines.push("```");
      const filename = `${templatesFolder}/${templateName}.md`;
      await this.app.vault.create(filename, lines.join("\n"));
      new import_obsidian2.Notice(`Template saved: ${templateName}`);
      this.dispatchEvent(new CustomEvent("template-saved", {
        detail: { filename, templateName }
      }));
    } catch (error) {
      console.error("Error saving template:", error);
      new import_obsidian2.Notice("Failed to save template");
    }
  }
  /**
   * Show save template dialog
   */
  async saveAsTemplate() {
    return new Promise((resolve) => {
      const modal = new import_obsidian2.Modal(this.app);
      modal.titleEl.setText("Save as Template");
      const input = modal.contentEl.createEl("input", {
        type: "text",
        placeholder: "Template name",
        value: this.state.tableName + " Template"
      });
      input.style.width = "100%";
      input.style.padding = "8px";
      input.style.marginBottom = "12px";
      const btnContainer = modal.contentEl.createDiv();
      btnContainer.style.display = "flex";
      btnContainer.style.justifyContent = "flex-end";
      btnContainer.style.gap = "8px";
      const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve();
      });
      const saveBtn = btnContainer.createEl("button", { text: "Save" });
      saveBtn.addEventListener("click", async () => {
        const templateName = input.value.trim();
        if (!templateName) {
          new import_obsidian2.Notice("Template name cannot be empty");
          return;
        }
        await this.saveTemplate(templateName);
        modal.close();
        resolve();
      });
      input.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          saveBtn.click();
        }
      });
      modal.onClose = () => resolve();
      modal.open();
      input.focus();
    });
  }
  /**
   * Load templates from .table-templates folder
   */
  async loadTemplates() {
    const templatesFolder = ".table-templates";
    const files = this.app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(templatesFolder + "/"));
    return files.map((file) => ({
      name: file.basename,
      file
    }));
  }
  /**
   * Load a specific template
   */
  async loadTemplate(file) {
    try {
      const content = await this.app.vault.read(file);
      const jsonMatch = content.match(/```json\n([\s\S]+?)\n```/);
      if (!jsonMatch) {
        new import_obsidian2.Notice("Invalid template format");
        return null;
      }
      const templateState = JSON.parse(jsonMatch[1]);
      new import_obsidian2.Notice(`Loaded template: ${templateState.tableName}`);
      return templateState;
    } catch (error) {
      console.error("Error loading template:", error);
      new import_obsidian2.Notice("Failed to load template");
      return null;
    }
  }
  /**
   * Import table from clipboard (markdown format)
   */
  async importFromClipboard() {
    try {
      const text = await navigator.clipboard.readText();
      const lines = text.split("\n").filter((l) => l.trim().includes("|"));
      if (lines.length < 2) {
        new import_obsidian2.Notice("No valid table found in clipboard");
        return null;
      }
      const headerLine = lines[0];
      const headers = headerLine.split("|").map((h) => h.trim()).filter((h) => h.length > 0);
      if (headers.length === 0) {
        new import_obsidian2.Notice("Could not parse table headers");
        return null;
      }
      const columns = headers.map((h) => {
        if (/^\d*d\d+$/i.test(h.trim())) {
          return { name: h, type: "dice", diceNotation: h.toLowerCase() };
        } else if (/^reroll$/i.test(h.trim())) {
          return { name: h, type: "reroll" };
        } else {
          return { name: h, type: "regular" };
        }
      });
      const rows = [];
      for (let i = 2; i < lines.length; i++) {
        const cells = lines[i].split("|").map((c) => c.trim()).filter((_, idx) => idx > 0 && idx <= headers.length);
        if (cells.length > 0) {
          const row = {};
          headers.forEach((header, idx) => {
            const col = columns[idx];
            const key = col.type === "dice" ? "range" : col.name;
            row[key] = cells[idx] || "";
          });
          rows.push(row);
        }
      }
      new import_obsidian2.Notice("Table imported from clipboard");
      return {
        tableName: "Imported Table",
        columns,
        rows,
        isPrivate: false
      };
    } catch (error) {
      console.error("Import error:", error);
      new import_obsidian2.Notice("Failed to import from clipboard");
      return null;
    }
  }
  /**
   * Copy table to clipboard as markdown
   */
  async copyToClipboard() {
    try {
      const markdown = this.generateMarkdown(this.state);
      await navigator.clipboard.writeText(markdown);
      new import_obsidian2.Notice("Copied to clipboard");
    } catch (error) {
      console.error("Error copying to clipboard:", error);
      new import_obsidian2.Notice("Failed to copy to clipboard");
    }
  }
};

// src/ui/validation/TableBuilderValidation.ts
var TableValidator = class {
  constructor(roller) {
    this.roller = roller;
  }
  /**
   * Validate complete table state
   */
  async validateTable(state) {
    const errors = [];
    this.validateTableName(state, errors);
    await this.validateRerollReferences(state, errors);
    await this.validateDiceRanges(state, errors);
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  /**
   * Validate table name is not empty
   */
  validateTableName(state, errors) {
    if (!state.tableName.trim()) {
      errors.push("Table name cannot be empty");
    }
  }
  /**
   * Validate all reroll references (table-level and row-level)
   */
  async validateRerollReferences(state, errors) {
    if (state.tableReroll) {
      const valid = await this.validateRerollReference(state.tableReroll);
      if (!valid) {
        errors.push(`Invalid table-level reroll reference: ${state.tableReroll}`);
      }
    }
    const rerollCol = state.columns.find((c) => c.type === "reroll");
    if (rerollCol) {
      for (const row of state.rows) {
        const rerollValue = row[rerollCol.name];
        if (rerollValue && rerollValue !== "\u2014" && rerollValue !== "-") {
          const valid = await this.validateRerollReference(rerollValue);
          if (!valid) {
            errors.push(`Invalid reroll reference: ${rerollValue}`);
          }
        }
      }
    }
  }
  /**
   * Validate a single reroll reference (can be comma-separated list)
   */
  async validateRerollReference(reference) {
    const tableNames = reference.split(",").map((t) => t.trim()).filter((t) => t);
    for (const name of tableNames) {
      const multiRollMatch = name.match(/^(\d*d\d+)\s+(.+)$/i);
      const actualTableName = multiRollMatch ? multiRollMatch[2].trim() : name;
      try {
        const tableFile = this.roller.getTableFile(actualTableName);
        if (!tableFile) {
          return false;
        }
      } catch (error) {
        return false;
      }
    }
    return true;
  }
  /**
   * Validate dice column ranges
   */
  async validateDiceRanges(state, errors) {
    const diceCol = state.columns.find((c) => c.type === "dice");
    if (!diceCol) {
      return;
    }
    const ranges = [];
    for (const row of state.rows) {
      const range = row.range;
      if (range) {
        const parsed = this.parseRange(range);
        if (parsed.min === 0 && parsed.max === 0) {
          errors.push(`Invalid range format: ${range}`);
        } else {
          ranges.push({ min: parsed.min, max: parsed.max, raw: range });
        }
      }
    }
    this.checkRangeOverlaps(ranges, errors);
    if (diceCol.diceNotation && ranges.length > 0) {
      this.checkRangeCoverage(diceCol.diceNotation, ranges, errors);
    }
  }
  /**
   * Parse a range string into min and max values
   */
  parseRange(rangeStr) {
    if (!rangeStr)
      return { min: 0, max: 0 };
    const trimmed = rangeStr.trim();
    if (/^\d+$/.test(trimmed)) {
      const num = parseInt(trimmed);
      return { min: num, max: num };
    }
    const rangeMatch = trimmed.match(/^(\d+)[\-\u2013\u2014](\d+)$/);
    if (rangeMatch) {
      return {
        min: parseInt(rangeMatch[1]),
        max: parseInt(rangeMatch[2])
      };
    }
    return { min: 0, max: 0 };
  }
  /**
   * Check for duplicate or overlapping ranges
   */
  checkRangeOverlaps(ranges, errors) {
    for (let i = 0; i < ranges.length; i++) {
      for (let j = i + 1; j < ranges.length; j++) {
        const r1 = ranges[i];
        const r2 = ranges[j];
        if (r1.min <= r2.max && r2.min <= r1.max) {
          errors.push(`Duplicate or overlapping ranges: ${r1.raw} and ${r2.raw}`);
        }
      }
    }
  }
  /**
   * Check if ranges properly cover the expected dice values
   */
  checkRangeCoverage(diceNotation, ranges, errors) {
    const match = diceNotation.match(/(\d*)d(\d+)/i);
    if (!match) {
      return;
    }
    const numDice = match[1] ? parseInt(match[1]) : 1;
    const sides = parseInt(match[2]);
    if (numDice === 1) {
      const sortedRanges = [...ranges].sort((a, b) => a.min - b.min);
      if (sortedRanges[0].min !== 1) {
        errors.push(`Dice ranges should start at 1 (found: ${sortedRanges[0].min})`);
      }
      const lastRange = sortedRanges[sortedRanges.length - 1];
      if (lastRange.max !== sides) {
        errors.push(
          `Dice ranges should end at ${sides} for ${diceNotation} (found: ${lastRange.max})`
        );
      }
      const hasOverlaps = this.hasOverlaps(ranges);
      if (!hasOverlaps) {
        for (let i = 0; i < sortedRanges.length - 1; i++) {
          const current = sortedRanges[i];
          const next = sortedRanges[i + 1];
          if (current.max + 1 !== next.min) {
            errors.push(`Gap in dice ranges between ${current.raw} and ${next.raw}`);
          }
        }
      }
    }
  }
  /**
   * Check if there are any overlapping ranges
   */
  hasOverlaps(ranges) {
    return ranges.some(
      (r1, i) => ranges.some((r2, j) => i !== j && r1.min <= r2.max && r2.min <= r1.max)
    );
  }
};

// src/ui/components/ColumnsEditor.ts
var import_obsidian3 = require("obsidian");
var ColumnsEditor = class {
  constructor(app, container, initialState) {
    this.columnsList = null;
    this.draggedColumnIndex = -1;
    this.app = app;
    this.container = container;
    this.state = initialState;
  }
  /**
   * Updates the component state and re-renders
   */
  updateState(newState) {
    this.state = newState;
    this.render();
  }
  /**
   * Renders the columns editor UI
   */
  render() {
    this.container.empty();
    this.columnsList = this.container.createDiv({ cls: "columns-list" });
    this.state.columns.forEach((col, index) => {
      this.renderColumnItem(col, index);
    });
    this.renderAddButtons();
  }
  /**
   * Renders a single column item
   */
  renderColumnItem(col, index) {
    if (!this.columnsList)
      return;
    const colItem = this.columnsList.createDiv({ cls: "column-item" });
    const dragHandle = colItem.createDiv({ cls: "drag-handle", text: "\u22EE\u22EE" });
    dragHandle.draggable = true;
    dragHandle.addEventListener("dragstart", (e) => this.onColumnDragStart(e, index));
    dragHandle.addEventListener("dragover", (e) => this.onColumnDragOver(e));
    dragHandle.addEventListener("drop", (e) => this.onColumnDrop(e, index));
    const nameInput = colItem.createEl("input", {
      type: "text",
      value: col.name,
      placeholder: "Column name"
    });
    if (col.type === "reroll") {
      nameInput.disabled = true;
      nameInput.style.opacity = "0.6";
      nameInput.style.cursor = "not-allowed";
    }
    nameInput.addEventListener("input", () => {
      const updatedColumn = {
        ...col,
        name: nameInput.value
      };
      if (col.type === "dice") {
        updatedColumn.diceNotation = nameInput.value;
      }
      this.dispatchColumnUpdated(index, updatedColumn);
    });
    colItem.createSpan({ text: `(${col.type})`, cls: "column-type" });
    if (col.type === "dice" && col.diceNotation) {
      const generateBtn = colItem.createEl("button", {
        text: "Generate Rows...",
        cls: "table-builder-btn-small"
      });
      generateBtn.style.marginLeft = "8px";
      generateBtn.addEventListener("click", () => {
        this.dispatchGenerateRowsRequested(col.diceNotation);
      });
    }
    if (this.state.columns.length > 1) {
      const deleteBtn = colItem.createEl("button", { text: "\xD7", cls: "delete-btn" });
      deleteBtn.addEventListener("click", () => this.deleteColumn(index));
    }
  }
  /**
   * Renders add column buttons
   */
  renderAddButtons() {
    const addBtns = this.container.createDiv({ cls: "add-column-btns" });
    const hasDiceColumn = this.state.columns.some((c) => c.type === "dice");
    if (!hasDiceColumn) {
      const addDiceBtn = addBtns.createEl("button", {
        text: "+ Dice Column",
        cls: "table-builder-btn"
      });
      addDiceBtn.addEventListener("click", () => this.showAddDiceColumnModal());
    }
    const addRegularBtn = addBtns.createEl("button", {
      text: "+ Regular Column",
      cls: "table-builder-btn"
    });
    addRegularBtn.addEventListener("click", () => this.addColumn("regular"));
    const hasRerollColumn = this.state.columns.some((c) => c.type === "reroll");
    if (!hasRerollColumn) {
      const addRerollBtn = addBtns.createEl("button", {
        text: "+ Reroll Column",
        cls: "table-builder-btn"
      });
      addRerollBtn.addEventListener("click", () => this.addColumn("reroll"));
    }
  }
  /**
   * Shows modal for adding a dice column
   */
  showAddDiceColumnModal() {
    if (this.state.columns.some((c) => c.type === "dice")) {
      new import_obsidian3.Notice("Only one dice column is allowed");
      return;
    }
    const modal = new import_obsidian3.Modal(this.app);
    modal.titleEl.setText("Add Dice Column");
    modal.contentEl.createEl("label", { text: "Select dice type:" });
    const select = modal.contentEl.createEl("select");
    select.style.width = "100%";
    select.style.padding = "8px";
    select.style.marginTop = "8px";
    select.style.marginBottom = "12px";
    const diceOptions = ["d4", "d6", "d8", "d10", "d12", "d20", "d100", "custom"];
    diceOptions.forEach((dice) => {
      select.createEl("option", {
        text: dice === "custom" ? "Custom..." : dice,
        value: dice
      });
    });
    const customContainer = modal.contentEl.createDiv();
    customContainer.style.marginBottom = "12px";
    customContainer.style.display = "none";
    customContainer.createEl("label", { text: "Custom dice notation (e.g., d6, 2d6, d100):" });
    const customInput = customContainer.createEl("input", {
      type: "text",
      placeholder: "d6"
    });
    customInput.style.width = "100%";
    customInput.style.padding = "8px";
    customInput.style.marginTop = "4px";
    select.addEventListener("change", () => {
      if (select.value === "custom") {
        customContainer.style.display = "block";
        customInput.focus();
      } else {
        customContainer.style.display = "none";
      }
    });
    const btnContainer = modal.contentEl.createDiv();
    btnContainer.style.display = "flex";
    btnContainer.style.justifyContent = "flex-end";
    btnContainer.style.gap = "8px";
    const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => modal.close());
    const addBtn = btnContainer.createEl("button", { text: "Add" });
    addBtn.addEventListener("click", () => {
      let diceType = select.value;
      if (diceType === "custom") {
        diceType = customInput.value.trim().toLowerCase();
        if (!diceType) {
          new import_obsidian3.Notice("Please enter a dice notation");
          return;
        }
        if (!/^\d*d\d+$/.test(diceType)) {
          new import_obsidian3.Notice("Invalid dice notation. Use format like: d6, 2d6, d100");
          return;
        }
      }
      const newColumn = {
        name: diceType,
        type: "dice",
        diceNotation: diceType
      };
      this.dispatchColumnAdded(newColumn, 0);
      modal.close();
    });
    modal.open();
  }
  /**
   * Adds a regular or reroll column
   */
  addColumn(type) {
    if (type === "reroll" && this.state.columns.some((c) => c.type === "reroll")) {
      new import_obsidian3.Notice("Only one reroll column is allowed");
      return;
    }
    const name = type === "reroll" ? "reroll" : `Column ${this.state.columns.length}`;
    const newColumn = { name, type };
    this.dispatchColumnAdded(newColumn, this.state.columns.length);
  }
  /**
   * Deletes a column
   */
  deleteColumn(index) {
    if (this.state.columns.length <= 1) {
      new import_obsidian3.Notice("Cannot delete the last column");
      return;
    }
    const col = this.state.columns[index];
    this.dispatchColumnRemoved(col.name, index);
  }
  // Drag and drop handlers
  onColumnDragStart(e, index) {
    this.draggedColumnIndex = index;
    if (e.dataTransfer) {
      e.dataTransfer.effectAllowed = "move";
    }
  }
  onColumnDragOver(e) {
    e.preventDefault();
    if (e.dataTransfer) {
      e.dataTransfer.dropEffect = "move";
    }
  }
  onColumnDrop(e, targetIndex) {
    e.preventDefault();
    if (this.draggedColumnIndex === targetIndex)
      return;
    this.dispatchColumnReordered(this.draggedColumnIndex, targetIndex);
    this.draggedColumnIndex = -1;
  }
  // Event dispatchers
  dispatchColumnAdded(column, index) {
    const event = new CustomEvent("column-added", {
      detail: { column, index },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchColumnRemoved(columnName, index) {
    const event = new CustomEvent("column-removed", {
      detail: { columnName, index },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchColumnReordered(fromIndex, toIndex) {
    const event = new CustomEvent("column-reordered", {
      detail: { fromIndex, toIndex },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchColumnUpdated(index, column) {
    const event = new CustomEvent("column-updated", {
      detail: { index, column },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchGenerateRowsRequested(diceNotation) {
    const event = new CustomEvent("generate-rows-requested", {
      detail: { diceNotation },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  /**
   * Cleanup method to remove event listeners
   */
  destroy() {
    this.container.empty();
    this.columnsList = null;
  }
};

// src/ui/components/RowGridEditor.ts
var RowGridEditor = class {
  constructor(container, initialState) {
    this.selectedRowIndex = 0;
    this.activeContextMenu = null;
    this.activeMenuCloseListener = null;
    this.container = container;
    this.state = initialState;
  }
  /**
   * Updates the component state and re-renders
   */
  updateState(newState, selectedRowIndex) {
    this.state = newState;
    if (selectedRowIndex !== void 0) {
      this.selectedRowIndex = selectedRowIndex;
    }
    this.render();
  }
  /**
   * Gets the currently selected row index
   */
  getSelectedRowIndex() {
    return this.selectedRowIndex;
  }
  /**
   * Renders the row grid UI
   */
  render() {
    this.container.empty();
    if (this.state.rows.length === 0) {
      this.container.createDiv({
        text: 'No rows yet. Click "+ Add Row" to start.',
        cls: "empty-state"
      });
      return;
    }
    this.renderHeaderRow();
    this.state.rows.forEach((row, rowIndex) => {
      this.renderDataRow(row, rowIndex);
    });
  }
  /**
   * Renders the header row with column names
   */
  renderHeaderRow() {
    const headerRow = this.container.createDiv({ cls: "row-grid-header" });
    headerRow.createDiv({ text: "", cls: "row-number" });
    this.state.columns.forEach((col, colIndex) => {
      const headerCell = headerRow.createDiv({ text: col.name, cls: "grid-cell" });
      headerCell.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        this.dispatchColumnPasteRequested(colIndex, e.clientX, e.clientY);
      });
      headerCell.style.cursor = "context-menu";
    });
    headerRow.createDiv({ cls: "row-actions" });
  }
  /**
   * Renders a single data row
   */
  renderDataRow(row, rowIndex) {
    const rowEl = this.container.createDiv({ cls: "row-grid-row" });
    if (rowIndex === this.selectedRowIndex) {
      rowEl.addClass("selected");
    }
    const rowNum = rowEl.createDiv({ text: `${rowIndex + 1}`, cls: "row-number" });
    rowNum.addEventListener("click", () => {
      this.selectedRowIndex = rowIndex;
      this.updateRowSelection();
      this.dispatchRowSelectionChanged(rowIndex);
    });
    this.state.columns.forEach((col, colIndex) => {
      const cellKey = col.type === "dice" ? "range" : col.name;
      const cellValue = row[cellKey] || "";
      const cell = rowEl.createDiv({ cls: "grid-cell" });
      const input = cell.createEl("input", {
        type: "text",
        value: cellValue,
        placeholder: col.type === "dice" ? "1-6" : "Value"
      });
      input.addEventListener("focus", () => {
        if (this.selectedRowIndex !== rowIndex) {
          this.selectedRowIndex = rowIndex;
          this.updateRowSelection();
          this.dispatchRowSelectionChanged(rowIndex);
        }
      });
      input.addEventListener("input", () => {
        this.dispatchRowUpdated(rowIndex, cellKey, input.value);
      });
      input.addEventListener("keydown", (e) => {
        this.handleCellKeydown(e, rowIndex, colIndex);
      });
    });
    const actionsCell = rowEl.createDiv({ cls: "row-actions" });
    const duplicateBtn = actionsCell.createEl("button", {
      text: "\u{1F4CB}",
      cls: "row-action-btn",
      attr: { "aria-label": "Duplicate row", "title": "Duplicate row" }
    });
    duplicateBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.dispatchRowDuplicated(rowIndex, rowIndex + 1);
    });
    const deleteBtn = actionsCell.createEl("button", {
      text: "\u2715",
      cls: "row-action-btn row-delete-btn",
      attr: { "aria-label": "Delete row", "title": "Delete row" }
    });
    deleteBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.dispatchRowDeleted(rowIndex);
    });
  }
  /**
   * Handles keyboard navigation in grid cells
   */
  handleCellKeydown(e, rowIndex, colIndex) {
    const rows = this.state.rows.length;
    const cols = this.state.columns.length;
    let newRow = rowIndex;
    let newCol = colIndex;
    let shouldMove = false;
    if (e.key === "Tab") {
      e.preventDefault();
      if (e.shiftKey) {
        newCol--;
        if (newCol < 0) {
          newCol = cols - 1;
          newRow--;
        }
      } else {
        newCol++;
        if (newCol >= cols) {
          newCol = 0;
          newRow++;
        }
      }
      shouldMove = true;
    } else if (e.key === "Enter") {
      e.preventDefault();
      if (e.shiftKey) {
        newRow--;
      } else {
        newRow++;
      }
      shouldMove = true;
    }
    if (shouldMove && newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
      this.selectedRowIndex = newRow;
      this.dispatchRowSelectionChanged(newRow);
      setTimeout(() => {
        const rowEls = this.container.querySelectorAll(".row-grid-row");
        const rowEl = rowEls[newRow];
        if (rowEl) {
          const inputs = rowEl.querySelectorAll("input");
          const input = inputs[newCol];
          if (input) {
            input.focus();
            input.select();
          }
        }
      }, 0);
    }
  }
  /**
   * Updates row selection visuals without rebuilding
   */
  updateRowSelection() {
    const rowEls = this.container.querySelectorAll(".row-grid-row");
    rowEls.forEach((el, idx) => {
      if (idx === this.selectedRowIndex) {
        el.addClass("selected");
      } else {
        el.removeClass("selected");
      }
    });
  }
  // Event dispatchers
  dispatchRowAdded(index) {
    const event = new CustomEvent("row-added", {
      detail: { index },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchRowDuplicated(sourceIndex, newIndex) {
    const event = new CustomEvent("row-duplicated", {
      detail: { sourceIndex, newIndex },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchRowDeleted(index) {
    const event = new CustomEvent("row-deleted", {
      detail: { index },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchRowUpdated(rowIndex, columnKey, value) {
    const event = new CustomEvent("row-updated", {
      detail: { rowIndex, columnKey, value },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchRowSelectionChanged(rowIndex) {
    const event = new CustomEvent("row-selection-changed", {
      detail: { rowIndex },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchColumnPasteRequested(columnIndex, clientX, clientY) {
    const event = new CustomEvent("column-paste-requested", {
      detail: { columnIndex, clientX, clientY },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  /**
   * Cleanup method to remove event listeners
   */
  destroy() {
    if (this.activeContextMenu && this.activeContextMenu.parentNode) {
      try {
        this.activeContextMenu.parentNode.removeChild(this.activeContextMenu);
      } catch (e) {
      }
    }
    if (this.activeMenuCloseListener) {
      document.removeEventListener("click", this.activeMenuCloseListener);
      this.activeMenuCloseListener = null;
    }
    this.container.empty();
  }
};

// src/ui/components/PreviewPanel.ts
var PreviewPanel = class {
  constructor(container, initialState) {
    this.markdownPreview = null;
    this.htmlPreview = null;
    this.activeTab = "markdown";
    this.container = container;
    this.state = initialState;
  }
  /**
   * Updates the component state and re-renders
   */
  updateState(newState) {
    this.state = newState;
    this.updatePreview();
  }
  /**
   * Renders the preview panel UI
   */
  render() {
    this.container.empty();
    const tabs = this.container.createDiv({ cls: "preview-tabs" });
    const markdownTab = tabs.createEl("button", {
      text: "Markdown",
      cls: "tab-btn" + (this.activeTab === "markdown" ? " active" : "")
    });
    const htmlTab = tabs.createEl("button", {
      text: "Preview",
      cls: "tab-btn" + (this.activeTab === "html" ? " active" : "")
    });
    markdownTab.addEventListener("click", () => {
      this.activeTab = "markdown";
      markdownTab.addClass("active");
      htmlTab.removeClass("active");
      if (this.markdownPreview)
        this.markdownPreview.addClass("active");
      if (this.htmlPreview)
        this.htmlPreview.removeClass("active");
    });
    htmlTab.addEventListener("click", () => {
      this.activeTab = "html";
      htmlTab.addClass("active");
      markdownTab.removeClass("active");
      if (this.htmlPreview)
        this.htmlPreview.addClass("active");
      if (this.markdownPreview)
        this.markdownPreview.removeClass("active");
    });
    const previewContainer = this.container.createDiv({ cls: "preview-container" });
    this.markdownPreview = previewContainer.createDiv({
      cls: "markdown-preview" + (this.activeTab === "markdown" ? " active" : "")
    });
    this.htmlPreview = previewContainer.createDiv({
      cls: "html-preview" + (this.activeTab === "html" ? " active" : "")
    });
    this.renderExportButtons();
    this.updatePreview();
  }
  /**
   * Renders export and action buttons
   */
  renderExportButtons() {
    const exportBtns = this.container.createDiv({ cls: "export-buttons" });
    const copyBtn = exportBtns.createEl("button", {
      text: "Copy to Clipboard",
      cls: "table-builder-btn"
    });
    copyBtn.addEventListener("click", () => this.handleCopyToClipboard());
    const saveBtn = exportBtns.createEl("button", {
      text: "Save",
      cls: "table-builder-btn"
    });
    saveBtn.addEventListener("click", () => this.dispatchSaveRequested(false));
    const saveAsBtn = exportBtns.createEl("button", {
      text: "Save As...",
      cls: "table-builder-btn"
    });
    saveAsBtn.addEventListener("click", () => this.dispatchSaveRequested(true));
    const loadBtn = exportBtns.createEl("button", {
      text: "Load Table",
      cls: "table-builder-btn"
    });
    loadBtn.addEventListener("click", () => this.dispatchLoadRequested());
    const importBtn = exportBtns.createEl("button", {
      text: "Import from Clipboard",
      cls: "table-builder-btn"
    });
    importBtn.addEventListener("click", () => this.dispatchImportFromClipboard());
    const exportDropdown = exportBtns.createEl("select", { cls: "export-format" });
    exportDropdown.createEl("option", { text: "Markdown", value: "md" });
    exportDropdown.createEl("option", { text: "CSV", value: "csv" });
    exportDropdown.createEl("option", { text: "JSON", value: "json" });
    const exportFileBtn = exportBtns.createEl("button", {
      text: "Export As...",
      cls: "table-builder-btn"
    });
    exportFileBtn.addEventListener("click", () => {
      const format = exportDropdown.value;
      this.dispatchExportRequested(format);
    });
  }
  /**
   * Updates the preview content
   */
  updatePreview() {
    if (!this.markdownPreview || !this.htmlPreview)
      return;
    this.markdownPreview.empty();
    const markdown = generateMarkdown(this.state);
    const pre = this.markdownPreview.createEl("pre");
    pre.createEl("code", { text: markdown });
    this.htmlPreview.empty();
    this.renderHTMLPreview(this.htmlPreview);
  }
  /**
   * Renders HTML preview of the table
   */
  renderHTMLPreview(container) {
    container.createEl("h2", { text: this.state.tableName });
    if (this.state.isPrivate || this.state.tableReroll) {
      const info = container.createDiv({ cls: "directives-info" });
      if (this.state.isPrivate) {
        info.createSpan({ text: "\u{1F512} Private", cls: "badge" });
      }
      if (this.state.tableReroll) {
        info.createSpan({ text: `\u21BB Rerolls: ${this.state.tableReroll}`, cls: "badge" });
      }
    }
    const table = container.createEl("table", { cls: "preview-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    this.state.columns.forEach((col) => {
      headerRow.createEl("th", { text: col.name });
    });
    const tbody = table.createEl("tbody");
    this.state.rows.forEach((row) => {
      const tr = tbody.createEl("tr");
      this.state.columns.forEach((col) => {
        const key = col.type === "dice" ? "range" : col.name;
        tr.createEl("td", { text: row[key] || "" });
      });
    });
  }
  /**
   * Handles copy to clipboard action
   */
  handleCopyToClipboard() {
    const markdown = generateMarkdown(this.state);
    this.dispatchCopyToClipboard(markdown);
  }
  // Event dispatchers
  dispatchCopyToClipboard(content) {
    const event = new CustomEvent("copy-to-clipboard", {
      detail: { content },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchSaveRequested(saveAs) {
    const event = new CustomEvent("save-requested", {
      detail: { saveAs },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchExportRequested(format) {
    const event = new CustomEvent("export-requested", {
      detail: { format },
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchLoadRequested() {
    const event = new CustomEvent("load-requested", {
      detail: {},
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  dispatchImportFromClipboard() {
    const event = new CustomEvent("import-from-clipboard", {
      detail: {},
      bubbles: true
    });
    this.container.dispatchEvent(event);
  }
  /**
   * Cleanup method to remove event listeners
   */
  destroy() {
    this.container.empty();
    this.markdownPreview = null;
    this.htmlPreview = null;
  }
};

// src/ui/modals/TableBuilderModals.ts
var import_obsidian4 = require("obsidian");
var ConfirmModal = class extends import_obsidian4.Modal {
  constructor(app, title, message, onConfirm, options) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
    this.confirmText = (options == null ? void 0 : options.confirmText) || "Confirm";
    this.cancelText = (options == null ? void 0 : options.cancelText) || "Cancel";
    this.isDangerous = (options == null ? void 0 : options.isDangerous) || false;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText(this.title);
    contentEl.createEl("p", { text: this.message });
    const btnContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = btnContainer.createEl("button", { text: this.cancelText });
    cancelBtn.addClass("table-builder-btn");
    cancelBtn.addEventListener("click", () => this.close());
    const confirmBtn = btnContainer.createEl("button", { text: this.confirmText });
    confirmBtn.addClass("table-builder-btn");
    if (this.isDangerous) {
      confirmBtn.addClass("mod-warning");
    }
    confirmBtn.addEventListener("click", () => {
      this.onConfirm();
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/TableBuilderView.ts
var VIEW_TYPE_TABLE_BUILDER = "table-builder";
function getDefaultState() {
  return {
    tableName: "New Table",
    columns: [
      { name: "d6", type: "dice", diceNotation: "d6" },
      { name: "Result", type: "regular" }
    ],
    rows: generateDefaultRows("d6", 6),
    isPrivate: false
  };
}
var TableBuilderView = class extends import_obsidian5.ItemView {
  constructor(leaf, roller) {
    super(leaf);
    // UI components
    this.columnsEditor = null;
    this.rowGridEditor = null;
    this.previewPanel = null;
    // UI containers
    this.leftPanel = null;
    this.rightPanel = null;
    this.tableNameInput = null;
    // State flags
    this.hasUnsavedChanges = false;
    this.currentFile = null;
    this.previewDebounceTimer = null;
    this.roller = roller;
    this.parser = new TableParser();
    this.stateManager = new StateManager(getDefaultState());
    this.tableIO = new TableIO(this.app, this.currentFile, this.parser);
    this.validator = new TableValidator(this.roller);
  }
  getViewType() {
    return VIEW_TYPE_TABLE_BUILDER;
  }
  getDisplayText() {
    const asterisk = this.hasUnsavedChanges ? "*" : "";
    return `Table Builder${asterisk}`;
  }
  getIcon() {
    return "table";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("table-builder-view");
    const splitContainer = container.createDiv({ cls: "table-builder-split" });
    this.leftPanel = splitContainer.createDiv({ cls: "table-builder-left-panel" });
    this.rightPanel = splitContainer.createDiv({ cls: "table-builder-right-panel" });
    this.buildLeftPanel();
    this.buildRightPanel();
    this.setupEventListeners();
  }
  async onClose() {
    if (this.hasUnsavedChanges) {
      console.warn("TableBuilder: Closing with unsaved changes");
    }
    this.columnsEditor = null;
    this.rowGridEditor = null;
    this.previewPanel = null;
    if (this.previewDebounceTimer) {
      clearTimeout(this.previewDebounceTimer);
      this.previewDebounceTimer = null;
    }
  }
  /**
   * Builds the left panel with toolbar, table name, columns, directives, and rows
   */
  buildLeftPanel() {
    if (!this.leftPanel)
      return;
    const toolbar = this.leftPanel.createDiv({ cls: "table-builder-toolbar" });
    this.buildToolbar(toolbar);
    const nameSection = this.leftPanel.createDiv({ cls: "table-builder-section" });
    nameSection.createEl("label", { text: "Table Name:" });
    this.tableNameInput = nameSection.createEl("input", {
      type: "text",
      value: this.stateManager.getState().tableName,
      cls: "table-builder-input"
    });
    this.tableNameInput.addEventListener("input", () => this.handleTableNameChange());
    const columnsSection = this.leftPanel.createDiv({ cls: "table-builder-section" });
    columnsSection.createEl("h3", { text: "Columns" });
    const columnsContainer = columnsSection.createDiv();
    this.columnsEditor = new ColumnsEditor(this.app, columnsContainer, this.stateManager.getState());
    this.columnsEditor.render();
    const directivesSection = this.leftPanel.createDiv({ cls: "table-builder-section" });
    directivesSection.createEl("h3", { text: "Directives" });
    this.buildDirectivesEditor(directivesSection);
    const rowsSection = this.leftPanel.createDiv({ cls: "table-builder-section" });
    rowsSection.createEl("h3", { text: "Rows" });
    const rowsContainer = rowsSection.createDiv();
    this.rowGridEditor = new RowGridEditor(rowsContainer, this.stateManager.getState());
    this.rowGridEditor.render();
    const addRowBtn = rowsSection.createEl("button", {
      text: "+ Add Row",
      cls: "table-builder-btn"
    });
    addRowBtn.addEventListener("click", () => this.handleAddRow());
  }
  /**
   * Builds the toolbar with undo/redo and bulk operations
   */
  buildToolbar(toolbar) {
    const undoButton = toolbar.createEl("button", { text: "Undo", cls: "table-builder-btn" });
    undoButton.addEventListener("click", () => this.handleUndo());
    const redoButton = toolbar.createEl("button", { text: "Redo", cls: "table-builder-btn" });
    redoButton.addEventListener("click", () => this.handleRedo());
    const clearResultsBtn = toolbar.createEl("button", {
      text: "Clear Results",
      cls: "table-builder-btn"
    });
    clearResultsBtn.addEventListener("click", () => this.handleClearResults());
    const deleteAllBtn = toolbar.createEl("button", {
      text: "Delete All Rows",
      cls: "table-builder-btn"
    });
    deleteAllBtn.addEventListener("click", () => this.handleDeleteAllRows());
  }
  /**
   * Builds the directives editor (isPrivate and tableReroll)
   */
  buildDirectivesEditor(container) {
    const state = this.stateManager.getState();
    const privateContainer = container.createDiv({ cls: "directive-item" });
    const privateCheckbox = privateContainer.createEl("input", {
      type: "checkbox",
      cls: "table-builder-checkbox"
    });
    privateCheckbox.checked = state.isPrivate;
    privateCheckbox.addEventListener("change", () => this.handlePrivateChange(privateCheckbox.checked));
    privateContainer.createEl("label", { text: "Private (hidden from table picker)" });
    const rerollContainer = container.createDiv({ cls: "directive-item" });
    rerollContainer.createEl("label", { text: "Table Reroll:" });
    const rerollInput = rerollContainer.createEl("input", {
      type: "text",
      value: state.tableReroll || "",
      placeholder: "e.g., TableName",
      cls: "table-builder-input"
    });
    rerollInput.addEventListener("input", () => this.handleTableRerollChange(rerollInput.value));
  }
  /**
   * Builds the right panel with preview and export
   */
  buildRightPanel() {
    if (!this.rightPanel)
      return;
    this.previewPanel = new PreviewPanel(this.rightPanel, this.stateManager.getState());
    this.previewPanel.render();
  }
  /**
   * Sets up event listeners for all components
   */
  setupEventListeners() {
    this.stateManager.addEventListener("state-changed", (e) => {
      this.handleStateChange(e.detail);
    });
    this.tableIO.addEventListener("file-saved", (e) => {
      this.handleFileSaved(e.detail);
    });
    this.tableIO.addEventListener("file-loaded", (e) => {
      this.handleFileLoaded(e.detail);
    });
    if (this.rightPanel) {
      this.rightPanel.addEventListener("load-requested", () => {
        this.tableIO.load();
      });
      this.rightPanel.addEventListener("save-requested", (e) => {
        this.tableIO.setState(this.stateManager.getState());
        if (e.detail.saveAs) {
          this.tableIO.saveAs();
        } else {
          this.tableIO.save();
        }
      });
      this.rightPanel.addEventListener("export-requested", (e) => {
        this.tableIO.setState(this.stateManager.getState());
        this.tableIO.exportAs(e.detail.format);
      });
      this.rightPanel.addEventListener("copy-to-clipboard", () => {
        this.tableIO.setState(this.stateManager.getState());
        this.tableIO.copyToClipboard();
      });
      this.rightPanel.addEventListener("import-from-clipboard", () => {
        this.tableIO.importFromClipboard();
      });
    }
  }
  // ==================== Event Handlers ====================
  /**
   * Handles state changes from StateManager
   */
  handleStateChange(state) {
    this.tableIO.setState(state);
    if (this.columnsEditor) {
      this.columnsEditor.updateState(state);
    }
    if (this.rowGridEditor) {
      const selectedRowIndex = this.rowGridEditor.getSelectedRowIndex();
      this.rowGridEditor.updateState(state, selectedRowIndex);
    }
    if (this.previewPanel) {
      this.previewPanel.updateState(state);
    }
    if (this.tableNameInput) {
      this.tableNameInput.value = state.tableName;
    }
    this.schedulePreviewUpdate();
  }
  /**
   * Handles table name changes
   */
  handleTableNameChange() {
    if (!this.tableNameInput)
      return;
    const currentState = this.stateManager.getState();
    const newState = {
      ...currentState,
      tableName: this.tableNameInput.value
    };
    this.stateManager.setState(newState);
    this.markUnsaved();
  }
  /**
   * Handles private checkbox changes
   */
  handlePrivateChange(isPrivate) {
    const currentState = this.stateManager.getState();
    const newState = {
      ...currentState,
      isPrivate
    };
    this.stateManager.setState(newState);
    this.markUnsaved();
  }
  /**
   * Handles table reroll input changes
   */
  handleTableRerollChange(tableReroll) {
    const currentState = this.stateManager.getState();
    const newState = {
      ...currentState,
      tableReroll: tableReroll || void 0
    };
    this.stateManager.setState(newState);
    this.markUnsaved();
  }
  /**
   * Handles undo button click
   */
  handleUndo() {
    if (this.stateManager.canUndo()) {
      this.stateManager.undo();
      this.markUnsaved();
    } else {
      new import_obsidian5.Notice("Nothing to undo");
    }
  }
  /**
   * Handles redo button click
   */
  handleRedo() {
    if (this.stateManager.canRedo()) {
      this.stateManager.redo();
      this.markUnsaved();
    } else {
      new import_obsidian5.Notice("Nothing to redo");
    }
  }
  /**
   * Handles clear results button click
   */
  handleClearResults() {
    const currentState = this.stateManager.getState();
    const newRows = currentState.rows.map((row) => {
      const newRow = { ...row };
      currentState.columns.forEach((col) => {
        if (col.type === "regular") {
          newRow[col.name] = "";
        }
      });
      return newRow;
    });
    const newState = {
      ...currentState,
      rows: newRows
    };
    this.stateManager.setState(newState);
    this.markUnsaved();
  }
  /**
   * Handles delete all rows button click
   */
  async handleDeleteAllRows() {
    const confirmed = await new Promise((resolve) => {
      const modal = new ConfirmModal(
        this.app,
        "Delete All Rows?",
        "This will delete all rows. Do you want to proceed?",
        () => resolve(true)
      );
      modal.open();
    });
    if (confirmed) {
      const currentState = this.stateManager.getState();
      const newState = {
        ...currentState,
        rows: []
      };
      this.stateManager.setState(newState);
      this.markUnsaved();
    }
  }
  /**
   * Handles add row button click
   */
  handleAddRow() {
    const currentState = this.stateManager.getState();
    const newRow = {};
    const newState = {
      ...currentState,
      rows: [...currentState.rows, newRow]
    };
    this.stateManager.setState(newState);
    this.markUnsaved();
  }
  /**
   * Handles file saved event from TableIO
   */
  handleFileSaved(detail) {
    new import_obsidian5.Notice(`Saved ${detail.tableName}`);
    this.currentFile = detail.file;
    this.hasUnsavedChanges = false;
    this.leaf.setViewState({ ...this.leaf.getViewState() });
  }
  /**
   * Handles file loaded event from TableIO
   */
  handleFileLoaded(detail) {
    this.stateManager.setState(detail.state);
    this.currentFile = detail.file;
    this.hasUnsavedChanges = false;
    this.leaf.setViewState({ ...this.leaf.getViewState() });
  }
  // ==================== Helper Methods ====================
  /**
   * Marks the view as having unsaved changes
   */
  markUnsaved() {
    this.hasUnsavedChanges = true;
    this.leaf.setViewState({ ...this.leaf.getViewState() });
  }
  /**
   * Schedules a preview update with debouncing
   */
  schedulePreviewUpdate() {
    if (this.previewDebounceTimer) {
      clearTimeout(this.previewDebounceTimer);
    }
    this.previewDebounceTimer = setTimeout(() => {
      if (this.previewPanel) {
        this.previewPanel.updateState(this.stateManager.getState());
      }
      this.previewDebounceTimer = null;
    }, 300);
  }
};

// main.ts
var TableRollerPlugin = class extends import_obsidian6.Plugin {
  async onload() {
    console.log("Loading Table Roller plugin");
    this.roller = new TableRollerCore(this.app);
    this.registerView(
      VIEW_TYPE_TABLE_BUILDER,
      (leaf) => new TableBuilderView(leaf, this.roller)
    );
    try {
      await this.roller.loadTables();
    } catch (error) {
      console.error("Error loading tables:", error);
    }
    this.addCommand({
      id: "open-table-builder",
      name: "Create/Edit Table",
      callback: async () => {
        const leaf = this.app.workspace.getLeaf("tab");
        await leaf.setViewState({
          type: VIEW_TYPE_TABLE_BUILDER,
          active: true
        });
      }
    });
    this.addRibbonIcon("table", "Create/Edit Table", async () => {
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.setViewState({
        type: VIEW_TYPE_TABLE_BUILDER,
        active: true
      });
    });
    this.addCommand({
      id: "roll-on-table",
      name: "Roll on table",
      callback: () => {
        const tables = this.roller.getTableNames();
        if (tables.length === 0) {
          console.warn("No tables found with table-roller frontmatter");
          return;
        }
        const selectorModal = new TableSelectorModal(this.app, tables, (tableNameWithModifier) => {
          try {
            let tableName = tableNameWithModifier;
            let modifier = 0;
            if (tableNameWithModifier.includes("@")) {
              const parts = tableNameWithModifier.split("@");
              tableName = parts[0];
              modifier = parseInt(parts[1]) || 0;
            }
            const showRollNumbers = selectorModal.showRollNumbers;
            const performRoll = () => {
              const result = this.roller.roll(tableName, void 0, modifier);
              new RollResultModal(this.app, result, performRoll, showRollNumbers).open();
            };
            performRoll();
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            if (errorMessage.includes("Ambiguous table reference")) {
              new ErrorModal(this.app, "Ambiguous Table Reference", errorMessage).open();
            } else {
              new ErrorModal(this.app, "Error", `Failed to roll on table:

${errorMessage}`).open();
            }
            console.error("Error rolling on table:", error);
          }
        }, this.roller);
        selectorModal.open();
      }
    });
    this.addCommand({
      id: "mark-as-table",
      name: "Mark current file as table",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile || activeFile.extension !== "md") {
          console.warn("No active markdown file");
          return;
        }
        try {
          const content = await this.app.vault.read(activeFile);
          const lines = content.split("\n");
          if (lines[0] === "---") {
            let endIndex = -1;
            for (let i = 1; i < lines.length; i++) {
              if (lines[i] === "---") {
                endIndex = i;
                break;
              }
            }
            if (endIndex > 0) {
              let hasProperty = false;
              for (let i = 1; i < endIndex; i++) {
                if (lines[i].match(/^table-roller\s*:/)) {
                  lines[i] = "table-roller: true";
                  hasProperty = true;
                  break;
                }
              }
              if (!hasProperty) {
                lines.splice(endIndex, 0, "table-roller: true");
              }
            }
          } else {
            lines.unshift("---", "table-roller: true", "---", "");
          }
          await this.app.vault.modify(activeFile, lines.join("\n"));
          console.log("File marked as table-roller");
        } catch (error) {
          console.error("Error marking file as table:", error);
        }
      }
    });
    this.addCommand({
      id: "reload-tables",
      name: "Reload all tables",
      callback: async () => {
        try {
          await this.roller.loadTables();
          console.log("Tables reloaded successfully");
        } catch (error) {
          console.error("Error reloading tables:", error);
        }
      }
    });
  }
  onunload() {
    console.log("Unloading Table Roller plugin");
  }
};
